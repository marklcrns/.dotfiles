# TODO: Create dynamic placeholders generator with python interpolation
# https://github.com/SirVer/ultisnips/blob/master/doc/examples/tabstop-generation/README.md

# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

# Mathjax snippets reference:
# https://github.com/gillescastel/latex-snippets/blob/master/tex.snippets

global !p
# Make all multi-line jump placeholder strings jumpable. Used with `post_jump`
def post_jump_expand_ph(snip):
	# Create annonymous snippet body
	anon_snippet_body = ""
	# Get start and end line number of expanded snippet
	start = snip.snippet_start[0]
	end = snip.snippet_end[0]
	for i in range(start, end + 1):
		# Append current line into annonymous snippet
		anon_snippet_body += snip.buffer[i]
		# Append new line if still not the end of snippet line
		anon_snippet_body += "" if i == end else "\n"

	# Delete old expanded snippet line till second to last snippet line
	for i in range(start, end):
		del snip.buffer[start]

	# Empty last old expanded snippet line while preserving line
	snip.buffer[start] = ''

	# Expand new annonymous snippet
	snip.expand_anon(anon_snippet_body)

# Mathjax matrix dictionary
boundaries = {
	"b": ["[", "]"],
	"B": ["{", "}"],
	"p": ["(", ")"],
	"v": ["|", "|"],
	"V": ["||", "||"]
}
weekdays = {
	"0": "Monday",
	"1": "Tuesday",
	"2": "Wednesday",
	"3": "Thursday",
	"4": "Friday",
	"5": "Saturday",
	"6": "Sunday"
}

# Todo meds taskk
def create_meds_task_head(desc, time):
	time = int(time)
	str_date_time = ""

	if time > 2399:
		time = time - 2400

	if time > 999:
		str_date_time += str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 1000 and time > 99:
		str_date_time += "0" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 100 and time > 0:
		str_date_time += "00" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time == 0:
		str_date_time += "00:00"

	str_date_time = "(" + tomorrow + " " + str_date_time + ")"

	task =  desc + " " + str_date_time
	return task

def create_meds_task(desc, time, offset):
	time = int(time) + (offset)
	date = today
	str_time = ""
	str_date_time = ""

	if time > 2399:
		time = time - 2400
		date = tomorrow

	if time > 999:
		str_time += str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 1000 and time > 99:
		str_time += "0" + str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += "0" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time < 100 and time > 0:
		str_time += "00" + str(time)
		str_time = str_time[:2] + ":" + str_time[2:]
		str_date_time += "00" + str(time)
		str_date_time = str_date_time[:2] + ":" + str_date_time[2:]
	elif time == 0:
		str_time += "00:00"
		str_date_time += "00:00"

	str_date_time = "(" + date + " " + str_date_time + ")"

	task =  str_time + " " + desc + " " + str_date_time
	return task
endglobal

# ====================Vimwiki/Markdown Snippets====================

snippet h1 "Header 1" bA
# $1
$0
endsnippet

snippet h2 "Header 2" bA
## $1
$0
endsnippet

snippet h3 "Header 3" bA
### $1
$0
endsnippet

snippet h4 "Header 4" bA
#### $1
$0
endsnippet

snippet h5 "Header 5" bA
##### $1
$0
endsnippet

snippet h6 "Header 6" bA
###### $1
$0
endsnippet

snippet tag "HTML tag <>" b
<$1>

${0:${VISUAL}}

</$1>
endsnippet

snippet itag "In-line HTML tag <>" wA
<$1>${0:${VISUAL}}</$1>
endsnippet

snippet '(.+)?fen' "Fenced code block" rbA
\`\`\``!p snip.rv = "" if match.group(1) == None else match.group(1)`
${0:${VISUAL}}
\`\`\`
endsnippet

snippet mcom "Markdown comment" bA
[$1]: # $0
endsnippet

snippet hcom "Markdown comment" bA
<!--- $1 --->$0
endsnippet

snippet br "Markdown breakline" w
<br>
endsnippet

snippet l "Simple link"
[${1:${VISUAL}}]($2)$0
endsnippet

snippet w "Web link"
[ðŸŒŽ ${1:${VISUAL}}]($2)$0
endsnippet

snippet m "Markdown file link" w
[â†ª ${1:${VISUAL}}]($2)$0
endsnippet

snippet v "Video link" w
[ðŸŽ¬ ${1:${VISUAL}}]($2)$0
endsnippet

snippet f "File Link" w
[â¬‡ ${1:${VISUAL}}](file:../../../$2)$0
endsnippet

snippet vf "vfile link" w
[â¬‡ ${1:${VISUAL}}](vfile:../../../$2)$0
endsnippet

snippet i "Image link" w
![${1:${VISUAL}}]($2)$0
endsnippet

snippet a "Markdown anchor link" w
[âš“ ${1:${VISUAL}}](${2:file}#${3:anchor-link})$0
endsnippet

snippet '#(.*)&a' "Convert anchor name ref into valid html id" irA
`!p
ref = match.group(1)

# Transform special chars into uniformed separators
ref = ref.replace(' ', '-')
ref = ref.replace('_', '-')
ref = ref.replace('\`', '-')
ref = ref.replace('.', '-')
ref = ref.replace(',', '')

conv_ref = ref

# Remove all prepending digits (including '-' separators) until non-digit
if ref[:1].isdigit():
	</a>
endsnippet

snippet pre "Html code block tag" w
<pre>
$0
</pre>
endsnippet

snippet kbd "Markdown key bindings tag" wA
<kbd>${1:${VISUAL}}</kbd>$0
endsnippet

snippet mbo "Markdown Bold tag" wA
**${1:${VISUAL}}**$0
endsnippet

snippet mit "Markdown Italic tag" wA
_${1:${VISUAL}}_$0
endsnippet

snippet hbo "Html bold tag" wA
<b>${1:${VISUAL}}</b>$0
endsnippet

snippet hit "Html italic tag" wA
<i>${1:${VISUAL}}</i>$0
endsnippet

snippet meta "Meta deta template" b
---
title: ${1:(INSERT TITLE)}
subtitle: ${2:(INSERT SUBTITLE)}
author: ${3:Mark Lucernas}
date: `date +'%b %d, %Y'`
---


$0
endsnippet

snippet temp "Vimwiki document template" b
---
title: ${1:(INSERT TITLE)}
subtitle: ${2:(INSERT SUBTITLE)}
author: ${3:Mark Lucernas}
date: `date +'%b %d, %Y'`
---


# $0


<br>

# Resources

endsnippet

snippet res "Vimwiki document resources header" b
<br>

# Resources

endsnippet

# Creates Todo list with Task Warrior.
# Prepend "!" to include "until" filter set to week_after.
# Prepend "#" to use taskwiki Preset Headers instead of Viewport
# Prepend "&" to generate nested todo (will automatically use Preset Header for parent header)
# Prepend "&&" to generate nested todo only
post_jump "post_jump_expand_ph(snip)"
snippet '([!#&]+)?td' "To-do list template" rbA
`!p
from datetime import datetime, timedelta
# parse date filename
fn_date = fn.rstrip('.md')
date = fn_date.split("-")
flags = match.group(1) if match.group(1) != None else ""
# get today, and day after tomorrow's date in string
base = datetime(int(date[0]), int(date[1]), int(date[2]))
today = datetime.strftime(base, '%Y-%m-%d')
today_verbose = datetime.strftime(base, '%b %d, %Y')
tomorrow = datetime.strftime(base + timedelta(1), '%Y-%m-%d')
week_after = datetime.strftime(base + timedelta(7), '%Y-%m-%d')

# Meta
title = f"title: To-do list"
subtitle = f"subtitle: {weekdays[str(base.weekday())]} to-do list. Managed by Taskwarrior and Taskwiki"
author = "author: Mark Lucernas"
date = f"date: {today_verbose}"
meta = f"---\n{title}\n{subtitle}\n{author}\n{date}\n---\n\n\n"
# Task warrior filters
proj = "project:Todo"
sched = f"scheduled:{today}"
due = f"due:{tomorrow}"
until = f"until:{week_after}"

result = ""
# Taskwiki Preset headers '||' or Viewport '|'
task_header = " || " if "#" in flags or "&" in flags else " | "
task_filter = proj + " " + sched + " " + due
# Append main task snippet into result
if "&&" not in flags:
	result += meta + "# Daily To-do" + task_header + task_filter
# Append side task snippet into result if '&' flag was given
if "&" in flags:
	if "&&" not in flags:
		result += "\n\n"
	result += "## ${1:Side Tasks}" + " | " + "+${2:side}"

# Append until filter if '!' flag was given (defaults to a week after)
if "!" in flags:
	result += " " + until

# Add empty checkbox
result += "\n* [ ] $0\n"

# Output
snip.rv = result`
endsnippet

snippet '(\d+)meds' "Description" rbA
`!p
from datetime import datetime, timedelta
# parse date filename
fn_date = fn.rstrip('.md')
date = fn_date.split("-")
init_time = match.group(1)
# get today, and day after tomorrow's date in string
base = datetime(int(date[0]), int(date[1]), int(date[2]))
today = datetime.strftime(base, '%Y-%m-%d')
tomorrow = datetime.strftime(base + timedelta(1), '%Y-%m-%d')
`* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 600)`
* [ ] `!p snip.rv = create_meds_task("2 Acetaminophen 6hrs", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 800)`
* [ ] `!p snip.rv = create_meds_task("1 Indomethacine 8hrs", init_time, 1600)`
* [ ] `!p snip.rv = create_meds_task("1 Aspirin EC 12hrs", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("1 Aspirin EC 12hrs", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("2 Sennosides-docusate 2daily", init_time, 0)`
* [ ] `!p snip.rv = create_meds_task("2 Sennosides-docusate 2daily", init_time, 1200)`
* [ ] `!p snip.rv = create_meds_task("1 Famotidine 1daily", init_time, 400)`
endsnippet

snippet due "Description" w
`!p
from datetime import datetime, timedelta
# parse date filename
fn_date = fn.rstrip('.md')
date = fn_date.split("-")
# get today, and day after tomorrow's date in string
base = datetime(int(date[0]), int(date[1]), int(date[2]))
tomorrow = datetime.strftime(base + timedelta(1), '%Y-%m-%d')
snip.rv = "(" + tomorrow + ")"`
endsnippet

snippet cbox "Todo checkbox" bA
* [ ] $0
endsnippet

post_jump "post_jump_expand_ph(snip)"
snippet '(\d+)(c)?t' "Markdown table (n)t" brA
`!p
t_column_ct = int(match.string[0:1])
t_header = "| $0  "
t_sep = "|---"
t_body = "|   "
t_header = t_header + ("|   " * (t_column_ct - 1)) + "|"
t_sep = t_sep + ("|---" * (t_column_ct - 1)) + "|"
t_body = t_body + ("|   " * (t_column_ct - 1)) + "|"

result = t_header + "\n" + t_sep + "\n" + t_body

if match.group(2) == "c":
	result = "<center>\n\n" + result + "\n\n</center>"

snip.rv = result
`
endsnippet

# Usage: [wrap]?table, optional wrapper char for each table cell
# Note: Lines should trail '&' char for splitting. Only until second to last.
# Ref: http://vimcasts.org/episodes/ultisnips-visual-placeholder/
snippet '(.+)?atab' "Markdown Table Builder" rbA
`!p
# Fetch visual selected text
text = snip.v.text

if "&" not in text: # Delimiter check
	snip.rv = text + "\n\n Snippet Error: No line delimiter. Insert '&' at the and of each line"

delim = " \t" # Delimeter
wrap = "" # Wraper char to wrap table cell items
if match.group(1) != None:
	# '\\' to escape wrap as char like '$' wont work as expected
	if match.group(1) == "$":
		wrap = "\\" + match.group(1)
	else:
		wrap = match.group(1)
lines = text.split("&") # Split lines delimited by '&'

result = "" # String container to be returned

line_count = 0
for line in lines: # Loop over lines
	line_tmp = ""
	separator = ""
	line = line.split(delim) # Split all items in line
	for item in line: # Loop over items in lines
		item = item.strip("\n")
		if line_count == 0:
			line_tmp += "| " + item + " " # Format without wrap and append item to line
			separator += "|" + ("-" * (len(item) + 2)) # "-"s multiplied by the length of item
		if line_count >= 1:
			line_tmp += "| " + wrap + item + wrap + " " # Format with wrap and append item to line

	result += line_tmp + "|\n" # Append new line and close table row

	if line_count == 0: # Table header and body separator
		result += separator + "|\n"

	line_count += 1

snip.rv = result`
endsnippet

snippet 't(\d+)' "Markdown table" rbA
`!p
num = match.group(1) # number of table columns

result = ""
for row in range(0, 3):
	for col in range(0, int(num)):
		if col == 0 and row == 0: # For first col and first row
			result += "| $0 "
		elif row == 1: # Header separator
			result += "|---"
		else:
			result += "|   " # Regular table cells
	# Close row and insert new line
	result += "|\n"

snip.rv = result
`
endsnippet

snippet tab2 "Two tables side by side" bA
<center>

<table>
%% Table Headings are OPTIONAL
<tr><th>${1:Table Heading 1}</th><th>${2:Table Heading 2}</th></tr>
<tr><td>

%% Insert first table HERE

</td><td>

%% Insert second table HERE

</td></tr>
</table>

</center>
endsnippet

snippet tab3 "Three tables side by side" bA
<center>

<table>
%% Table Headings are OPTIONAL
<tr><th>${1:Table Heading 1}</th><th>${2:Table Heading 2}</th><th>${3:Table Heading 3}</th></tr>
<tr><td>

%% Insert first table HERE

</td><td>

%% Insert second table HERE

</td><td>

%% Insert Third table HERE

</td></tr>
</table>

</center>
endsnippet

snippet TM "Markdown trademark symbol" i
&trade;
endsnippet

snippet R "Markdown registered symbol" i
&reg;
endsnippet

snippet C "Markdown copyright symbol" i
&copy;
endsnippet

# ==========Note taking snippets========== #
snippet tstamp "Video lecture timestamps" bA
Timestamps

	$0
endsnippet

snippet ttime "Video lecture timestamp item" iA
- ${1:title} ${2:1:00}
endsnippet

# TODO: Truncate regex match to fix "maxmempattern" error
# VERSION 2
# Usage: (00:00:00 or 00:00)<youtube-url>&y
snippet '((\d{1,2}:)?(\d{1,2}):(\d{2}))((https:\/\/)?(www\.)?(youtube.com))((\/embed\/)?(.*))&y' "Youtube video lecture time stamp with link" wrA
[(`!p snip.rv = match.group(1)`)](`!p
# check if hours exist
hours = match.group(2)
if hours:
	hours = int(hours).rstrip(":")
else:
	hours = 0

minutes = int(match.group(3))
seconds = int(match.group(4))
home_url = match.group(5)
http_url = match.group(6)
www_url = match.group(7)
domain_url = match.group(8)
video_url = match.group(9)
embed = match.group(10)
video_id = match.group(11)
link = ""

# check if valid home url
#if not http_url or not www_url:
#  if not http_url and not www_url:
#    link = "https://www." + domain_url
#  if not http_url:
#    link = "https://" + www_url + domain_url
#  if not www_url:
#    link = http_url + "www." + domain_url
#else:
#	link = http_url + www_url + domain_url
link = "https://www.youtube.com"

# check if video_url is embedded
if embed:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# convert timestamp to seconds then append to link
snip.rv = link + "&t=" + str((hours * 60) + (minutes * 60) + seconds)
`)
endsnippet

# Usage: <youtube-url>&y
snippet '(\()?((https:\/\/)?(www\.)?(youtube.com))((\/embed\/)?(.*))&y' "Clean and create Youtube link" wrA
`!p
home_url = match.group(2)
http_url = match.group(3)
www_url = match.group(4)
domain_url = match.group(5)
video_url = match.group(6)
embed = match.group(7)
video_id = match.group(8)
link = ""

# check if valid home url
#if not http_url or not www_url:
#  if not http_url and not www_url:
#    link = "https://www." + domain_url
#  if not http_url:
#    link = "https://" + www_url + domain_url
#  if not www_url:
#    link = http_url + "www." + domain_url
#else:
#	link = http_url + www_url + domain_url
link = "https://www.youtube.com"

# check if video_url is embedded
if embed:
	# exclude embed and replace with the standard "watch?v="
	video_url = "/watch?v=" + video_id

# strip unnecessary video_url features
for i in range(0, len(video_url)):
	if video_url[i] != "&":
		link += video_url[i]
	else:
		break

# If inside markdown link wrapper, don't wrap, else, wrap it.
if match.group(1):
  snip.rv = match.group(1) + link
else:
  snip.rv = "[VIDEO $1: $2](" + link + ")$0"
`
endsnippet

snippet term "Word or phrase definition" bA
<a name="$1">**${2:${VISUAL}}**</a>

- $0
endsnippet

snippet iterm "Word or phrase definition in-line" bA
<a name="$1">**${2:${VISUAL}}**</a>

- $0
endsnippet

# Usage: &name-of-link&alink
snippet '&?([A-Za-z- ]+)\&(t)?alink' "Word or pharse definition auto" wrA
[`!p
snip.rv = match.group(1).replace("-", " ")
`]($1#${2:`!p
		snip.rv = match.group(1).replace(" ", "-").lower() if match.group(2) == None else match.group(1).replace(" ", "-").lower() + "-term"
`})$0
endsnippet

# Usage:
# &terminology name&term
# Termininology name&iterm
# **Terminology name**&term
# **terminology name**&iterm
snippet '&?(\*\*)?([^.*\[\]#&]+)(\*\*)?&(i)?term$' "Word or pharse definition auto" wrA
<a name="`!p
term = match.group(2)
text = ""
copy = True
# check if theres parenthesis
parenthesis = set('()')
if any((c in parenthesis) for c in term):
	for i in range(0, len(term) - 1):
		if ((term[i] == "(" or term[i + 1] == "(") and copy == True):
			copy = False
			continue
		elif (term[i] == ")" and copy == False):
			copy = True
			continue

		if copy == True:
			text += term[i]
else:
  text = term

# Anchor link with '-term' appended to name
snip.rv = text.replace(" ", "-").lower() + '-term">**'``!p
# Capitalize term
snip.rv = match.group(2).capitalize()`$1**</a>`!p
# if '&iterm' make inline else the term definition in new line in markdown list
snip.rv = " - " if match.group(4) else "\n\n- "`$0
endsnippet


# ====================Mathjax Snippets with Mathjax====================

snippet b$$ "Mathjax block" bA
$$
${1:${VISUAL}}
$$
endsnippet

snippet $$ "Mathjax in-line" wA
$${1:${VISUAL}}$
endsnippet

snippet @@ "Mathjax text" iA
\text{${1:${VISUAL}}}$0
endsnippet

snippet xsbo "Mathjax symbol bold" wA
\boldsymbol{${1:${VISUAL}}}$0
endsnippet

snippet xmbo "Mathjax math bold" wA
\mathbf{${1:${VISUAL}}}$0
endsnippet

snippet xmit "Mathjax math italic" wA
\mathit{${1:${VISUAL}}}$0
endsnippet

snippet xtbo "Mathjax text bold" wA
\textbf{${1:${VISUAL}}}$0
endsnippet

snippet xtit "Mathjax text italic" wA
\textit{${1:${VISUAL}}}$0
endsnippet

snippet __ "Mathjax underline" w
\underline{${1:${VISUAL}}}$0
endsnippet

snippet nl "Mathjax empty line" bA
~\\\\
endsnippet

# Usage: n==, where n is the number of equations stack
post_jump "post_jump_expand_ph(snip)"
snippet '(\d+)==' "KaTex block align equations" brA
`!p
lines = match.group(1)
res = ""
placeholder = 1
for column in range(0, int(lines)):
	res = res + f"${placeholder} &= ${placeholder + 1} \\\\\\\\\n"
	placeholder = placeholder + 2
snip.rv = "\\begin{aligned}\n" + res[:-6] + "\n\\end{aligned}"
`$0
endsnippet

# Fractions
# ============================================================
snippet '(d|t)?f/' "Mathjax normal/display/textstyle fraction" riA
`!p
snip.rv = "\\" if match.group(1) == None else "\\" + match.group(1)
`frac{${1:${VISUAL}}}{$2}$0
endsnippet

# snippet '(((-)?\d+)|((-)?\d+)((\^|_)(\{.*\}|(-)?\d+).*)|((-)?\d+)?((\\)([A-Za-z]+)(\{.*\}|(-)?\d+)).*)/' "Mathjax tab auto fraction" wr
# \\frac{`!p snip.rv = match.group(1)`}{$1}$0
# endsnippet

snippet '^.*\)/' "Mathjax () auto fraction" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

# Exponents, Superscript, Subscript
# ============================================================

# TODO: Fix lookbehind fixed witdh pattern error
# Auto exponent/superscript
# Matches any number of digits, words, or outside of enclosing brackets
# or parenthesis character followed by '^' using negative lookbehind
# snippet '(?<=\d+|\w+|\(.*\)|\[.*\]|\{.*\})\^' "Mathjax auto exponent/superscript" ir
# ^{$1}$0
# endsnippet

# Auto subscript
# Matches any number of digits, words, or outside of enclosing brackets
# or parenthesis character followed by '_' using negative lookbehind
# snippet '(?<=\d+|\w+|\(.*\)|\[.*\]|\{.*\})_' "Mathjax auto subscript" ir
# _{$1}$0
# endsnippet

snippet sqrt "Mathjax square root" iA
\sqrt{${1:${VISUAL}}}$0
endsnippet

snippet '(\d+|n|x|y|z)rt' "Mathjax root of n" ir
\sqrt[`!p snip.rv = match.group(1)`]{$1}$0
endsnippet

snippet log "Mathjax logarithm function" i
\log_{$1}$0
endsnippet

snippet clog "Mathjax common logarithm function" i
\log
endsnippet

snippet lne "Mathjax natural log e" i
\ln_{${1:e}}$0
endsnippet

snippet ln "Mathjax natural log" i
\ln
endsnippet

snippet sr "Mathjax ^2" i
^2
endsnippet

snippet cb "Mathjax ^3" i
^3
endsnippet

# Symbols
# ============================================================

snippet '(\d+|[a-kx-z])deg' "Mathjax auto degrees symbol" irA
`!p snip.rv = match.group(1)`^{\circ}
endsnippet

snippet deg "Mathjax degrees symbol" w
\circ
endsnippet

snippet pi "Mathjax pi symbol" iw
\pi
endsnippet

snippet '(\d+)pi' "Mathjax auto pi symbol" irA
`!p snip.rv = match.group(1)`\pi
endsnippet

snippet 'iff' "Mathjax if and only if sign" i
\iff
endsnippet

snippet '+-' "Mathjax plus minus sign" i
\pm
endsnippet

snippet the "Mathjax theta symbol" i
\theta
endsnippet

snippet alp "Mathjax alpha symbol" i
\alpha
endsnippet

snippet bet "Mathjax beta symbol" i
\beta
endsnippet

snippet gam "Mathjax gamma symbol" i
\gamma
endsnippet

snippet del "Mathjax delta symbol" i
\delta
endsnippet

snippet Del "Mathjax triangle delta symbol" i
\Delta{$1}$0
endsnippet

snippet mu "Mathjax mu greek symbol" i
\mu
endsnippet

snippet eps "Mathjax epsilon symbol" i
\epsilon
endsnippet

snippet vep "Mathjax varepsilon symbol" i
\varepsilon
endsnippet

snippet phi "Mathjax phi symbol" i
\phi
endsnippet

snippet zeta "Mathjax zeta symbol" i
\zeta
endsnippet

snippet lamb "Mathjax lambda symbol" i
\lambda
endsnippet

snippet '....' "Mathjax ldots" wA
\ldots
endsnippet

snippet tf "Mathjax therefore dots" w
\therefore
endsnippet

snippet bc "Mathjax because dots" w
\because
endsnippet

snippet <= "Mathjax less than or equals to" w
\le
endsnippet

snippet >= "Mathjax greater than or equals to" w
\ge
endsnippet

snippet appr "Mathjax approximation symbol" w
\approx
endsnippet

snippet => "Mathjax implies" w
\implies
endsnippet

snippet =< "Mathjax implied by" w
\impliedby
endsnippet

snippet != "Mathjax not equals to" w
\neq
endsnippet

snippet '(\\|,),' "Matjax thin space" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\,\\,'
elif prefix == ',':
	snip.rv = '\\,'
`
endsnippet

snippet '(\\|!)!' "Matjax thin negative space" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\!\\!'
elif prefix == '!':
	snip.rv = '\\!'
`
endsnippet

snippet '(\\|:):' "Matjax medium space" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\:\\:'
elif prefix == ':':
	snip.rv = '\\:'
`
endsnippet

snippet '(\\|;);' "Matjax large space" rw
`!p
prefix = match.group(1)
if prefix == '\\':
	snip.rv = '\\;\\;'
elif prefix == ';':
	snip.rv = '\\;'
`
endsnippet

snippet ubr "Mathjax underbrace" i
\underbrace{${1:${VISUAL}}}$0
endsnippet

snippet obr "Mathjax overbrace" i
\overbrace{$1}$0
endsnippet

snippet inf "Mathjax infinity" i
\infty
endsnippet

snippet PP "Mathjax prime numbers" wA
\mathbb{P}
endsnippet

snippet NN "Mathjax natural numbers" wA
\mathbb{N}
endsnippet

snippet ZZ "Mathjax integer numbers" wA
\mathbb{Z}
endsnippet

snippet II "Mathjax irrational numbers" wA
\mathbb{I}
endsnippet

snippet QQ "Mathjax rational numbers" wA
\mathbb{Q}
endsnippet

snippet RR "Mathjax real numbers" wA
\mathbb{R}
endsnippet

snippet CC "Mathjax complex numbers" wA
\mathbb{C}
endsnippet

snippet SS "Mathjax section" wA
\S
endsnippet

snippet EE "Mathjax exists" wA
\exists
endsnippet

snippet AA "forall" wA
\forall
endsnippet

snippet nabl "nabla" wA
\nabla
endsnippet

snippet xx "cross" wA
\times
endsnippet

snippet * "Mathjax cdot" w
\cdot
endsnippet

snippet c** "Mathjax center dots" wA
\cdots
endsnippet

snippet 'v**' "Mathjax vertical dots" wA
\vdots
endsnippet

snippet 'd**' "Mathjax diagonal dots" wA
\ddots
endsnippet

snippet -> "to" i
\to
endsnippet

snippet !> "mapsto" iA
\mapsto
endsnippet

snippet '\\\' "setminus" i
\setminus
endsnippet

snippet >> ">>" i
\gg
endsnippet

snippet << "<<" i
\ll
endsnippet

snippet uar "Mathjax uparrow" w
\uparrow
endsnippet

snippet dar "Mathjax downarrow" w
\downarrow
endsnippet

snippet udar "Mathjax updownarrow" w
\updownarrow
endsnippet

snippet lar "Mathjax leftarrow" w
\leftarrow
endsnippet

snippet rar "Mathjax rightarrow" w
\rightarrow
endsnippet

snippet lrar "Mathjax leftrightarrow" w
\leftrightarrow
endsnippet

snippet Llar "Mathjax long leftarrow" w
\Longleftarrow
endsnippet

snippet Lrar "Mathjax long rightarrow" w
\Longrightarrow
endsnippet

snippet Llrar "Mathjax long leftrightarrow" w
\Longleftrightarrow
endsnippet

snippet ovlar "Mathjax overset left" w
\overset{$1}\leftarrow$0
endsnippet

snippet unlar "Mathjax underset rightarrow" w
\underset{$1}\leftarrow$0
endsnippet

snippet ovrar "Mathjax overset rightarrow" w
\overset{$1}\rightarrow$0
endsnippet

snippet unrar "Mathjax underset rightarrow" w
\underset{$1}\rightarrow$0
endsnippet

snippet ' "Mathjax prime" i
^{\prime}
endsnippet

snippet " "Mathjax double prime" i
^{\prime \prime}
endsnippet

snippet "' "Mathjax tripple prime" i
^{\prime \prime \prime}
endsnippet

snippet ~ "Mathjax ~" w
\sim
endsnippet

snippet ~~ "Mathjax Approximation" wA
\approx
endsnippet

snippet vec "Mathjax vector" i
\vec{${1:${VISUAL}}}$0
endsnippet

snippet mag "Mathjax vector's magnitude" i
\\|${1:${VISUAL}}\\|$0
endsnippet

snippet <> "Mathjax angled bracets" i
\langle ${1:${VISUAL}} \rangle$0
endsnippet

snippet || "Mathjax parallel sign" i
\parallel
endsnippet

snippet | "Mathjax mid sign" i
\mid
endsnippet

snippet subs "subset" i
\subset
endsnippet

snippet notin "not in " iA
\not\in
endsnippet

snippet in "in" w
\in
endsnippet

snippet Nn "cap" iA
\cap
endsnippet

snippet UU "cup" i
\cup
endsnippet

snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

snippet OO "emptyset" i
\emptyset
endsnippet

snippet <! "normal" iA
\triangleleft
endsnippet

snippet <> "hokje" iA
\diamond
endsnippet

snippet dint "integral" wA
\int_{${1:-\infty}}^{${2:\infty}} ${3:${VISUAL}} $0
endsnippet

snippet sum "Mathjax sum symbol" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n z^n}
endsnippet

snippet taylor "taylor" w
\sum_{${1:k}=${2:0}}^{${3:\infty}} ${4:c_$1} (x-a)^$1 $0
endsnippet

snippet lim "limit" i
\lim_{${1:n} \to ${2:\infty}}
endsnippet

snippet limsup "limsup" w
\limsup_{${1:n} \to ${2:\infty}}
endsnippet

snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet

snippet part "d/dx" w
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet

snippet norm "norm" i
\|$1\|$0
endsnippet

snippet mcal "mathcal" iA
\mathcal{$1}$0
endsnippet

snippet invs "inverse" iA
^{-1}
endsnippet

snippet comp "Mathjax complement" i
^{c}
endsnippet

snippet 'det' "Mathjax determinant" w
\det $0
endsnippet

snippet phan "Mathjax phantom placeholder" w
\phantom{$1}$0
endsnippet

snippet nphan "Mathjax negative phantom placeholder" wA
\phantom{-}$0
endsnippet

snippet col# "Mathjax text color" iA
{\color{#${1:ff0000}}{${2:${VISUAL}}}}$0
endsnippet

snippet '(\d+)?(sin|cos|tan|csc|sec|cot)(\d+[a-zA-Z0-9]*|[a-zA-Z]+)?' "Mathjax trig functions" r
`!p
mult = "" if match.group(1) == None else match.group(1)
expo = "" if match.group(3) == None else "^{" + match.group(3) + "}"
snip.rv = mult + "\\" + match.group(2) + expo
`{$1}$0
endsnippet


# Matrices, absolute value and parenthises
# ============================================================
snippet bigp "Mathjax big ()" i
\bigl( ${1:${VISUAL}} \bigr)$0
endsnippet

snippet Bigp "Mathjax very big ()" i
\Bigl( ${1:${VISUAL}} \Bigr)$0
endsnippet

snippet bigb "Mathjax big {}" i
\bigl\\{ ${1:${VISUAL}} \bigr\\}$0
endsnippet

snippet Bigb "Mathjax very big {}" i
\Bigl\\{ ${1:${VISUAL}} \Bigr\\}$0
endsnippet

snippet bigs "Mathjax big []" i
\bigl[ ${1:${VISUAL}} \bigr]$0
endsnippet

snippet Bigs "Mathjax Big []" i
\Bigl[ ${1:${VISUAL}} \Bigr]$0
endsnippet

snippet biga "Mathjax big |" i
\bigl\\| ${1:${VISUAL}} \bigr\\|$0
endsnippet

snippet Biga "Mathjax very big |" i
\Bigl\\| ${1:${VISUAL}} \Bigr\\|$0
endsnippet

snippet lrp "Mathjax left right ()" i
\left ( ${1:${VISUAL}} \right )$0
endsnippet

snippet lrb "Mathjax left right ()" i
\left \\{ ${1:${VISUAL}} \right \\}$0
endsnippet

snippet lrs "Mathjax left right []" i
\left [ ${1:${VISUAL}} \right ]$0
endsnippet

snippet lra "Mathjax absolute value" i
\left | ${1:${VISUAL}} \right |$0
endsnippet

snippet lrda "Mathjax double absolute value" i
\left \| ${1:${VISUAL}} \right \|$0
endsnippet

snippet bmat "Mathjax in-line brackets matrix" wbA
\begin{bmatrix} ${1:${VISUAL}} \end{bmatrix}$0
endsnippet

snippet Bmat "Mathjax in-line curly braces matrix" wbA
\begin{Bmatrix} ${1:${VISUAL}} \end{Bmatrix}$0
endsnippet

snippet pmat "Mathjax in-line parenthesis matrix" wbA
\begin{pmatrix} ${1:${VISUAL}} \end{pmatrix}$0
endsnippet

snippet vmat "Mathjax in-line determinant matrix" wbA
\begin{vmatrix} ${1:${VISUAL}} \end{vmatrix}$0
endsnippet

snippet Vmat "Mathjax in-line double absolute values matrix" wbA
\begin{Vmatrix} ${1:${VISUAL}} \end{Vmatrix}$0
endsnippet

# Usage: "i((l or r)or(b))n,nm", where `i` (optional) is the in-line trigger
# either `l or r` (optional) as separators, `b` (optional) as the boundary type
# , and `n,n` as the matrix size (rows, column). No spaces and ignore
# parenthesis, and can't have both separators and boundary together.
post_jump "post_jump_expand_ph(snip)"
snippet '\b(i)?(((l)?(r)?)(b|B|v|V|p?))(\d+,\d+)m' "Mathjax matrix" wrA
`!p
inline = match.group(1)
left = match.group(4) # left matrix separator
right = match.group(5) # right matrix separator
boundary = match.group(6) # boundary type

# Determine if in-line or block
indent = ""
if inline:
	inline = " "
else:
	inline = "\n"
	indent = "\t"

if left or right:
	# Left boundary with right separator. Default boundary is "|"
	if left and right == None:
		if boundary:
			left = "\\left" + boundaries[f"{boundary}"][0]
			right = "\\right|"
		else:
			left = "\\left|"
			right = "\\right|"
	# Right boundary only
	elif left == None and right:
		if boundary:
			left = "\\left."
			right = "\\right" + boundaries[f"{boundary}"][1]
		else:
			left = "\\left."
			right = "\\right|"
	# Left and right separator
	elif left and right:
		if boundary:
			left = "\\left" + boundaries[f"{boundary}"][0]
			right = "\\right" + boundaries[f"{boundary}"][1]
		else:
			left = "\\left|"
			right = "\\right|"
	# Remove boundary
	boundary = ""
elif boundary:
	# No separator
	left = ""
	right = ""
else:
	# No boundary and separator
	left = ""
	right = ""
	boundary = ""
# Matrix size
size = match.group(7).split(",")
# LaTeX matrix wrapper
begin = left + "\\begin{" + boundary + "matrix}" + inline
end = inline + "\\end{" + boundary + "matrix}" + right + "$0"
result = "" # result value
placeholder = 1 # placeholder number for snippet jumps

# Matrix entries
for column in range(0, int(size[0])):
	# Indent (if block) every column and add snippet placeholder each matrix entries
	result = result + indent + "${" + f"{placeholder}:{placeholder}" + "}"
	placeholder = placeholder + 1
	for row in range(1, int(size[1])):
		result = result + " & ${" f"{placeholder}:{placeholder}" + "}"
		placeholder = placeholder + 1
	# Append \\ and new line (if block) at the end of each row
	result = result + " \\\\\\\\" + inline

# removes unnecessary backslashes and wraps with LaTeX matrix wrapper
snip.rv = begin + result[:-6] + end
`
endsnippet

