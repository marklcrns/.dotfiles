#!/bin/bash

# Updates all specified dotfiles from DOTFILES_SOURCE_DIR into
# DOTFILES_TARGET_DIR.
# Uses `cmp` to compare files and `diff -c` to display changes when `-V` flag is
# given.
#
# The $DOTFILESRC specifies the location of .dotfilesrc file to override default
# script variables.
#
# ########################## Script Global Variables ###########################
#
# DOTFILES_LIST       = Bash array list of config (dot) files or directory to
#                       update.
# DOTFILES_SOURCE_DIR = Default source directory to distribute dotfiles from.
# DOTFILES_TARGET_DIR = Default target directory to distribute dotfiles into.
# LOG_FILE_DIR        = Log file directory.
# LOG_FILE            = Log file name. Only logs on `-d` flag or debug mode.
#                       Defaults to current timestamp.
#
# ##############################################################################
#
# Author : Mark Lucernas <https://github.com/marklcrns>
# Date   : 2020-08-05


# Default script variables
DOTFILES_LIST=()
DOTFILES_SOURCE_DIR="${HOME}"
DOTFILES_TARGET_DIR="${HOME}/Projects/.dotfiles"
LOG_FILE_DIR="${HOME}/log"
LOG_FILE="$(date +"%Y-%m-%dT%H:%M:%S")_$(basename -- $0).log"

SCRIPTPATH="$( cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 ; pwd -P )"

# Ansi color code variables
RED="\e[0;91m"
BLUE="\e[0;94m"
GREEN="\e[0;92m"
YELLOW="\033[1;33m"
WHITE="\e[0;97m"
EXPAND_BG="\e[K"
RED_BG="\e[0;101m${expand_bg}"
BLUE_BG="\e[0;104m${expand_bg}"
GREEN_BG="\e[0;102m${expand_bg}"
YELLOW_BG="\e[0;103m${expand_bg}"
BOLD="\e[1m"
ULINE="\e[4m"
NC="\e[0m" # No/reset color


# Source rc file if exist
if [[ -e "${DOTFILESRC}" ]]; then
  source "${DOTFILESRC}"
fi


# Display help
usage() {
cat << EOF
USAGE:

Updates all specified dotfiles from DOTFILES_SOURCE_DIR into
DOTFILES_TARGET_DIR.

  dotupdate [ -bdsvVy ]

OPTIONS:

   -b : backup files
   -d : debug mode (redirect output in log file)
   -s : silent
   -v : verbose
   -V : very verbose
   -y : skip confirmation
   -h : help

EOF
}

# Set flag options
while getopts "bdsvVyh" opt; do
  case "$opt" in
    b) [[ -n "$IS_BACKUP"       ]] && unset IS_BACKUP                  || IS_BACKUP=true;;
    d) [[ -n "$DEBUG"           ]] && unset DEBUG                      || DEBUG=true;;
    s) [[ -n "$IS_SILENT"       ]] && unset IS_SILENT                  || IS_SILENT=true;;
    v) [[ -n "$IS_VERBOSE"      ]] && unset IS_VERBOSE                 || IS_VERBOSE=true;;
    V) [[ -n "$IS_VERY_VERBOSE" ]] && unset IS_VERBOSE IS_VERY_VERBOSE || IS_VERBOSE=true; IS_VERY_VERBOSE=true;;
    y) [[ -n "$SKIP_CONFIRM"    ]] && unset SKIP_CONFIRM               || SKIP_CONFIRM=true;;
    h) usage && exit 0;;
    *) usage && echo -e "${SCRIPTPATH}:\n${RED}ERROR: Invalid flag.${NC}"
      exit 1
  esac
done 2>/dev/null
shift "$((OPTIND-1))" # explanation https://unix.stackexchange.com/a/214151

# Stores message into $IN if string argument is passed in, else read from stdin
# and store it in $IN (used with pipe '|').  Only log message on debug mode.
# Echoes $IN if used with pipe.
log() {
  if [[ -n "$1" ]]; then
    IN="$1"
    [[ -n "${DEBUG}" ]] && echo -e "${IN}" >> "${LOG_FILE_PATH}"
  else
    read IN
    if [[ -n ${IN} ]]; then
      [[ -n "${DEBUG}" ]] && echo -e "${IN}" | tee -a "${LOG_FILE_PATH}"
    fi
  fi
}

echolog(){
  message=$1
  if [[ -n "${message}" ]]; then
    # echo if verbose
    [[ -n "${IS_VERBOSE}" ]] && [[ -z "${IS_SILENT}" ]] && echo -e "${message}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  else # Print newline if no message
    [[ -n "${IS_VERBOSE}" ]] && echo -e ""
    [[ -n "${DEBUG}" ]] && echo -e "" >> "${LOG_FILE_PATH}"
  fi
}

ok() {
  message="$1"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${GREEN}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 0
}

warning() {
  message="$1"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

abort() {
  message="$1"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 1
}

error() {
  message="$1"
  exitcode="$2"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${RED}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  # Exit with specified exit code. Do not exit if no exit code
  if [[ -n ${exitcode} ]]; then
    [[ ${exitcode} -ge 0 ]] && exit ${exitcode}
  fi
}

# Strip trailing '/' in DIR path variables
DOTFILES_SOURCE_DIR=$(echo ${DOTFILES_SOURCE_DIR} | sed 's,/*$,,')
DOTFILES_TARGET_DIR=$(echo ${DOTFILES_TARGET_DIR} | sed 's,/*$,,')
LOG_FILE_DIR=$(echo ${LOG_FILE_DIR} | sed 's,/*$,,')

# Log stdout and stderr to $LOG_FILE in $LOG_FILE_DIR
if [[ -n "${DEBUG}" ]]; then
  # Append LOG_FILE
  LOG_FILE_PATH="${LOG_FILE_DIR}/${LOG_FILE}"
  # Create log directory if not existing
  if [[ ! -d "${LOG_FILE_DIR}" ]]; then
    mkdir -p "${LOG_FILE_DIR}"
  fi
  # Initialize log file
  echo -e "${SCRIPTPATH} log outputs\n" > ${LOG_FILE_PATH}
fi

################################# START SCRIPT #################################

# TODO: Make bidirectional
#       Make diffing changes detect the most recent file
# Compares two file path (would compare recursively if files are directories)
# and returns all files with discrepancies.
# Require at least 3 arguments or args $1, $2, and $3 to execute.
#
# ARGS:
# $1 = Source file path
# $2 = Target file path
# $3 = List of detected changes, including source and target file path separated
#      by ';', and delimited by '\n'.
# $4 = Detected changes count
# $5 = Total files compared
# $6 = Pass in integer '1' to turn on IS_SILENT
#
# Returns $3, $4, $5 variable args with new values from execution.
detect_changes() {
  local __source=$1
  local __target=$2
  local __changes_list=$3
  local __changes_count=$4
  local __total_files_count=$5
  local IS_SILENT=$6

  # Check args count
  [[ $# -lt 3 ]] && echolog "${RED}${FUNCNAME[0]}: Invalid number of arguments${NC}" && return 1
  # Exit if invalid path
  [[ ! -e "${__source}" ]] && \
    echolog "${RED}${FUNCNAME[0]}: Invalid source path \'${__source}\'${NC}" && return 2
  [[ ! -e "${__target}" ]] && \
    echolog "${RED}${FUNCNAME[0]}: Invalid source path \'${__target}\'${NC}" && return 2

  local __tmp_changes_list
  local __tmp_changes_count
  local __tmp_total_files_count

  # Strip all trailing backslashes '/'
  __source=$(echo "${__source}" | sed 's,/*$,,')
  __target=$(echo "${__target}" | sed 's,/*$,,')

  if [[ -d "${__source}" ]]; then # Directory dotfile
    # Recursively compare
    while IFS= read -r -d '' __source_file; do
      # Strip all trailing backslashes '/'
      __source_file=$(echo "${__source_file}" | sed 's,/*$,,')
      # Get relative path
      __rel_path_file=$(echo "${__source_file}" | sed "s,${__source}/,,")
      __target_file="${__target}/${__rel_path_file}"
      # Compare dotfiles in destination dir with local copy in source dir
      if cmp -s "${__source_file}" "${__target_file}"; then
        if [[ ${IS_SILENT} -ne 1 ]]; then
          echolog "No changes detected in ${__source_file}"
        else
          log "No changes detected in ${__source_file}"
        fi
      else
        if [[ ${IS_SILENT} -ne 1 ]]; then
          echolog "${YELLOW}Changes detected:${NC}"
          echolog "${BLUE}SOURCE ${__source_file}${NC}"
          echolog "${BLUE}TARGET ${__target_file}${NC}"
        else
          log "${YELLOW}Changes detected:${NC}"
          log "${BLUE}SOURCE ${__source_file}${NC}"
          log "${BLUE}TARGET ${__target_file}${NC}"
        fi
        # Record changes
        __tmp_changes_count=$(expr ${__tmp_changes_count} + 1)
        if [[ -z ${__tmp_changes_list} ]]; then
          __tmp_changes_list="${__source_file};${__target_file}"
        else
          __tmp_changes_list="${__tmp_changes_list}\n${__source_file};${__target_file}"
        fi
      fi
      # Increment total files compared
      __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
    done < <(find "${__source}" -not -path "*/.git/*" -type f -print0) # Process substitution for outside variables
  else # Non-directory dotfile
    # Compare dotfiles in destination dir with local copy in source dir
    if cmp -s "${__source}" "${__target}"; then
      if [[ ${IS_SILENT} -ne 1 ]]; then
        echolog "No Changes detected in ${__source}"
      else
        log "No Changes detected in ${__source}"
      fi
    else
      if [[ ${IS_SILENT} -ne 1 ]]; then
        echolog "${YELLOW}Changes detected:${NC}"
        echolog "${BLUE}SOURCE ${__source}${NC}"
        echolog "${BLUE}TARGET ${__target}${NC}"
      else
        log "${YELLOW}Changes detected:${NC}"
        log "${BLUE}SOURCE ${__source}${NC}"
        log "${BLUE}TARGET ${__target}${NC}"
      fi
      # Record changes
      __tmp_changes_count=$(expr ${__tmp_changes_count} + 1)
      if [[ -z ${__tmp_changes_list} ]]; then
        __tmp_changes_list="${__source};${__target}"
      else
        __tmp_changes_list="${__tmp_changes_list}\n${__source};${__target}"
      fi
    fi
    # Increment total files compared
    __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
  fi
  # Return variables
  [[ -n "${__changes_list}" ]]      && eval $__changes_list="'$__tmp_changes_list'"
  [[ -n "${__changes_count}" ]]     && eval $__changes_count=$__tmp_changes_count
  [[ -n "${__total_files_count}" ]] && eval $__total_files_count=$__tmp_total_files_count
}

# Compares two file path (would compare recursively if files are directories)
# and returns all files that does not exists in the target file or directory.
# Require at least 3 arguments or args $1, $2, and $3 to execute.
#
# ARGS:
# $1 = Source file path
# $2 = Target file path
# $3 = List of source files that does not exist in the target file path.
# $4 = Detected changes count
# $5 = Total files compared
# $6 = Pass in integer '1' to turn on IS_SILENT
#
# Returns $3, $4, $5 variable args with new values from execution.
detect_delete() {
  local __source=$1
  local __target=$2
  local __changes_list=$3
  local __deleted_count=$4
  local __total_files_count=$5
  local IS_SILENT=$6

  # Check args count
  [[ $# -lt 3 ]] && echolog "${RED}${FUNCNAME[0]}: Invalid number of arguments${NC}" && return 1
  # Exit if invalid path
  [[ ! -e "${__source}" ]] && \
    echolog "${RED}${FUNCNAME[0]}: Invalid source path \'${__source}\'${NC}" && return 2
  [[ ! -e "${__target}" ]] && \
    echolog "${RED}${FUNCNAME[0]}: Invalid source path \'${__target}\'${NC}" && return 2

  local __tmp_changes_list
  local __tmp_deleted_count
  local __tmp_total_files_count

  # Strip all trailing backslashes '/'
  __source=$(echo "${__source}" | sed 's,/*$,,')
  __target=$(echo "${__target}" | sed 's,/*$,,')

  if [[ -d "${__source}" ]]; then # Directory dotfile
    # Recursively compare
    while IFS= read -r -d '' __source_file; do
      # Strip all trailing backslashes '/'
      __source_file=$(echo "${__source_file}" | sed 's,/*$,,')
      # Get relative path
      __rel_path_file=$(echo "${__source_file}" | sed "s,${__source}/,,")
      __target_file="${__target}/${__rel_path_file}"
      # Check deleted files
      if [[ -e "${__target_file}" ]]; then
        if [[ ${IS_SILENT} -ne 1 ]]; then
          echolog "File exist in ${__target_file}"
        else
          log "File exists in ${__target_file}"
        fi
      else
        if [[ ${IS_SILENT} -ne 1 ]]; then
          echolog "${RED}File to be deleted ${__source_file}${NC}"
        else
          log "${RED}File to be deleted ${__source_file}${NC}"
        fi
        # Record changes
        __tmp_deleted_count=$(expr ${__tmp_deleted_count} + 1)
        if [[ -z ${__tmp_changes_list} ]]; then
          __tmp_changes_list="${__source_file}"
        else
          __tmp_changes_list="${__tmp_changes_list}\n${__source_file}"
        fi
      fi
      # Increment total files compared
      __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
    done < <(find "${__source}" -not -path "*/.git/*" -type f -print0) # Process substitution for outside variables
  else # Non-directory dotfile
    # Check deleted files
    if [[ -e "${__target}" ]]; then
      if [[ ${IS_SILENT} -ne 1 ]]; then
        echolog "File exist in ${__target}"
      else
        log "File exists in ${__target}"
      fi
    else
      if [[ ${IS_SILENT} -ne 1 ]]; then
        echolog "${RED}File does not exist ${__source}${NC}"
      else
        log "${RED}File does not exist ${__source}${NC}"
      fi
      # Record changes
      __tmp_deleted_count=$(expr ${__tmp_deleted_count} + 1)
      if [[ -z ${__tmp_changes_list} ]]; then
        __tmp_changes_list="${__source}"
      else
        __tmp_changes_list="${__tmp_changes_list}\n${__source}"
      fi
    fi
    # Increment total files compared
    __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
  fi
  # Return variables
  [[ -n "${__changes_list}" ]]      && eval $__changes_list="'$__tmp_changes_list'"
  [[ -n "${__deleted_count}" ]]     && eval $__deleted_count=$__tmp_deleted_count
  [[ -n "${__total_files_count}" ]] && eval $__total_files_count=$__tmp_total_files_count
}

# TODO: Implement more elegant dotfiles backup
# if [[ -n "${IS_BACKUP}" ]]; then
# fi

total_changes_count=0
total_deleted_count=0
total_files_count=0

echolog "Detecting dotfiles changes..."
echolog
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip source directory from path
  source_stripped=$(echo "$dotfile" | sed "s,${DOTFILES_SOURCE_DIR}/,,")

  detect_changes "${dotfile}" "${DOTFILES_TARGET_DIR}/${source_stripped}" changes changes_count files_count
  detect_delete "${DOTFILES_TARGET_DIR}/${source_stripped}" "${dotfile}" delete delete_count

  # Initialize counters if none
  [[ -z "${changes_count}" ]] && changes_count=0
  [[ -z "${delete_count}" ]] && delete_count=0
  [[ -z "${files_count}" ]] && files_count=0

  # Update changes list
  if [[ -n "${changes}" ]]; then
    if [[ -z ${changes_list} ]]; then
      changes_list="${changes}"
    else
      changes_list="${changes_list}\n${changes}"
    fi
    # Increment changes counter
    total_changes_count=$(expr ${total_changes_count} + ${changes_count})
  fi
  if [[ -n "${delete}" ]]; then
    if [[ -z ${changes_list} ]]; then
      changes_list="${delete}"
    else
      changes_list="${changes_list}\n${delete}"
    fi
    # Increment delete counter
    total_deleted_count=$(expr ${total_deleted_count} + ${delete_count})
  fi
  # Increment total files counters
  total_files_count=$(expr ${total_files_count} + ${files_count} + ${delete_count})
done

# Abort if no changes or delete detected
[[ ${total_changes_count} -eq 0 ]] && [[ ${total_deleted_count} -eq 0 ]] &&
  abort "\nAborting... No dotfiles to backup."

echolog
echolog "${ULINE}Files with changes:${NC}"
echolog

modified_files_count=0
new_files_count=0

# Loop over changes list and diff if IS_VERY_VERBOSE, else echolog source file
while IFS= read -r file_tuple; do
  # Split file_tuple
  IFS=';' read -r -a file_arr <<< "${file_tuple}"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
    # Copy source to target file
  if [[ -z "${target_file}" ]]; then # check if target_file is missing
    echolog "${RED}-${source_file}${NC}"
  elif [[ -e "${target_file}" ]]; then # check if target_file not existing
    # Diff source and target file
    if [[ -n "${IS_VERY_VERBOSE}" ]] && [[ -z "${IS_SILENT}" ]]; then
      if command -v colordiff &> /dev/null; then
        diff -c "${target_file}" "${source_file}" | colordiff
      else
        diff -c "${target_file}" "${source_file}" --color
      fi
    else
      # echolog source file if not very verbose
      echolog "${YELLOW}${source_file}${NC}"
    fi
    modified_files_count=$((modified_files_count+1))
  else
    echolog "${GREEN}+${target_file}${NC}"
    new_files_count=$((new_files_count+1))
  fi
done < <(echo -e "${changes_list}") # Process substitution for outside variables

# Changes and deletes tally
echolog
echolog "Total files to updated: \t${total_files_count}"
[[ ${modified_files_count} -gt 0 ]] &&
  echolog "${YELLOW}Total changed files: \t\t${modified_files_count}${NC}"
[[ ${new_files_count} -gt 0 ]] &&
  echolog "${GREEN}Total new files: \t\t${new_files_count}${NC}"
[[ ${total_deleted_count} -gt 0 ]] &&
  echolog "${RED}Total delete files: \t\t${total_deleted_count}${NC}"
echolog


# Confirmation
if [[ -z "${SKIP_CONFIRM}" ]]; then
  log "Do you wish to continue? (Y/y): "
  confirm "Do you wish to continue? (Y/y): "
  if [[ "${?}" -eq 1 ]]; then
    abort "Update aborted."
  elif [[ "${?}" -eq 2 ]]; then
    error "Unsupported shell"
  fi
fi

# Copy changes to destination directory and delete missing files
echo -e "${changes_list}" | while IFS= read -r file_tuple; do
  IFS=';' read -r -a file_arr <<< "$file_tuple"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
  target_dir="$(dirname "${target_file}")"
  if [[ -z "${target_file}" ]]; then # check if target_file is missing
    rm -v "${source_file}" | log
  elif [[ -d "${target_dir}" ]]; then # Check target dir path
    cp -rLv ${source_file} ${target_file} | log
  else # Create target dir if not existing
    mkdir -p "${target_dir}"
    cp -rLv ${source_file} ${target_file} | log
  fi
done

# Final check
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip source directory from path
  source_stripped=$(echo "$dotfile" | sed "s,${DOTFILES_SOURCE_DIR}/,,")

  detect_changes "${dotfile}" "${DOTFILES_TARGET_DIR}/${source_stripped}" changes changes_count files_count 1
  detect_delete "${DOTFILES_TARGET_DIR}/${source_stripped}" "${dotfile}" delete delete_count files_count 1
done

# Catch errors
[[ ${changes_count} -gt 0 ]] || [[ ${delete_count} -gt 0 ]] &&
  error "Dotupdate failed. Changes persists" 1

ok "Dotfiles update successful!"

