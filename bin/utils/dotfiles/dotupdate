#!/bin/bash

# Updates all specified dotfiles from $DOTFILES_LIST into specified location.
#
# The $DOTFILESRC specifies the location of .dotfilesrc file to override default
# script variables.
#
# ############################## Script Variables ##############################
#
# DOTFILES_LIST = Bash array list of config (dot) files or directory to update.
# LOG_FILE_DIR  = Log file directory.
# LOG_FILE      = Log file name. Only logs on `-d` flag or debug mode.
#                       Defaults to current timestamp.
#
# ##############################################################################
#
# Author : Mark Lucernas -- https://github.com/marklcrns
# Date   : 2020-08-05


# Default script variables
DOTFILES_DEST_DIR="${HOME}/Projects/.dotfiles"
DOTFILES_LIST=()
LOG_FILE_DIR="${HOME}/log"
LOG_FILE="$(date +"%Y-%m-%dT%H:%M:%S")_$(basename -- $0).log"

# Source rc file if exist
if [[ -e "${DOTFILESRC}" ]]; then
  source "${DOTFILESRC}"
fi

# Display help
usage() {
cat << EOF
USAGE:

Updates all specified dotfiles from \$DOTFILES_LIST into specified location.

  dotupdate [ -dvy ]

OPTIONS:

   -d : debug mode (redirect output in log file)
   -v : verbose
   -y : skip confirmation
   -h : help

EOF
}

# Set flag options
while getopts "dvVyh" opt; do
  case "$opt" in
    d) [[ -n "$DEBUG"           ]] && unset DEBUG                      || DEBUG=true;;
    v) [[ -n "$IS_VERBOSE"      ]] && unset IS_VERBOSE                 || IS_VERBOSE=true;;
    V) [[ -n "$IS_VERY_VERBOSE" ]] && unset IS_VERBOSE IS_VERY_VERBOSE || IS_VERBOSE=true; IS_VERY_VERBOSE=true;;
    y) [[ -n "$SKIP_CONFIRM"    ]] && unset SKIP_CONFIRM               || SKIP_CONFIRM=true;;
    h) usage && exit 0;;
    *) error "Invalid flag.";;
  esac
done 2>/dev/null
shift "$((OPTIND-1))" # explanation https://unix.stackexchange.com/a/214151


SCRIPT_PATH="$(realpath -s "${0}")"
# Strip trailing '/' in DIR path variables
DOTFILES_DEST_DIR=$(echo ${DOTFILES_DEST_DIR} | sed -r "s,(.*)/$,\1,")
LOG_FILE_DIR=$(echo ${LOG_FILE_DIR} | sed -r "s,(.*)/$,\1,")

# Log stdout and stderr to $LOG_FILE in $LOG_FILE_DIR
if [[ -n "${DEBUG}" ]]; then
  # Strip trailing '/' in LOG_FILE_DIR path and append "/$LOG_FILE"
  LOG_FILE_PATH="$(echo ${LOG_FILE_DIR} | sed -r "s,(.*)/$,\1,")/${LOG_FILE}"
  # Create log directory if not existing
  if [[ ! -d "${LOG_FILE_DIR}" ]]; then
    mkdir -p "${LOG_FILE_DIR}"
  fi
  # Initialize log file
  echo -e "${SCRIPT_PATH} log outputs\n" > ${LOG_FILE_PATH}
fi


# Ansi color code variables
# Ref: https://techstop.github.io/bash-script-colors/
RED="\e[0;91m"
BLUE="\e[0;94m"
GREEN="\e[0;92m"
YELLOW='\033[1;33m'
WHITE="\e[0;97m"
EXPAND_BG="\e[K"
RED_BG="\e[0;101m${expand_bg}"
BLUE_BG="\e[0;104m${expand_bg}"
GREEN_BG="\e[0;102m${expand_bg}"
YELLOW_BG="\e[0;103m${expand_bg}"
BOLD="\e[1m"
ULINE="\e[4m"
NC="\e[0m" # No/reset color

log() {
  # Stores message into $IN if string argument is passed in,
  # else read from stdin and store it in $IN (used with pipe '|').
  # Only log message on debug mode. Echoes $IN if used with pipe.
  if [[ -n "$1" ]]; then
    IN="$1"
    [[ -n "${DEBUG}" ]] && echo -e "${IN}" >> "${LOG_FILE_PATH}"
  else
    read IN
    if [[ -n ${IN} ]]; then
      [[ -n "${DEBUG}" ]] && echo -e "${IN}" | tee -a "${LOG_FILE_PATH}"
    fi
  fi

}

echolog(){
  message=$1
  if [[ -n "${message}" ]]; then
    [[ -n ${IS_VERBOSE} ]] && echo -e "${message}"
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  else # Print newline if no message
    [[ -n ${IS_VERBOSE} ]] && echo -e ""
    [[ -n "${DEBUG}" ]] && echo -e "" >> "${LOG_FILE_PATH}"
  fi
}

ok() {
  message="$1"
  if [[ -n "${message}" ]]; then
    echo -e "${GREEN}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

warning() {
  message="$1"
  if [[ -n "${message}" ]]; then
    echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

abort() {
  message="$1"
  if [[ -n "${message}" ]]; then
    echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 0
}

error() {
  message="$1"
  exitcode="$2"
  if [[ -n "${message}" ]]; then
    echo -e "${RED}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  # Exit with specified exit code. Do not exit if no exit code
  if [[ -n ${exitcode} ]]; then exist
    [[ ${exitcode} -ge 0 ]] && exit ${exitcode}
  fi
}

# Compares two file path (would compare recursively if files are directories).
# Require at least 3 arguments or args $1, $2, and $3 to execute.
#
# ARGS:
# $1 = Source file path
# $2 = Target file path
# $3 = List of detected changes, including source and target separated by ';',
#      and delimited by '\n'.
# $4 = Detected changes count
# $5 = Total files compared
# $6 = Pass in integer '1' to turn on IS_SILENT
#
# Returns $3, $4, $5 variable args with new values from execution.
cmp_files() {
  local __source=$1
  local __target=$2
  local __changes_list=$3
  local __changes_count=$4
  local __total_files_count=$5
  local IS_SILENT=$6

  # Check args count
  [[ $# -lt 3 ]] && echolog "${RED}${FUNCNAME[0]}: Invalid number of arguments${NC}" && return 1
  # Exit if invalid path
  [[ ! -e "${__source}" ]] && \
    echolog "${RED}${FUNCNAME[0]}: Invalid source path \'${__source}\'${NC}" && return 2
  [[ ! -e "${__target}" ]] && \
    echolog "${RED}${FUNCNAME[0]}: Invalid source path \'${__target}\'${NC}" && return 2

  local __tmp_changes_list
  local __tmp_changes_count
  local __tmp_total_files_count

  if [[ -d "${__source}" ]]; then # Directory dotfile
    # Recursively compare
    while IFS= read -r -d '' __source_file; do

      # Get relative path
      __rel_path_file=$(echo "${__source_file}" | sed "s,${__source},,")
      __target_file="${__target}/${__rel_path_file}"

      # Compare dotfiles in destination dir with local copy in home dir
      if cmp -s "${__source_file}" "${__target_file}"; then
        if [[ ${IS_SILENT} -ne 1 ]]; then
          echolog "No changes detected in ${__source_file}"
        else
          log "No changes detected in ${__source_file}"
        fi
      else
        if [[ ${IS_SILENT} -ne 1 ]]; then
          echolog "${YELLOW}Changes detected:${NC}"
          echolog "${BLUE}SOURCE ${__source_file}${NC}"
          echolog "${BLUE}TARGET ${__target_file}${NC}"
        else
          log "${YELLOW}Changes detected:${NC}"
          log "${BLUE}SOURCE ${__source_file}${NC}"
          log "${BLUE}TARGET ${__target_file}${NC}"
        fi
        # Record changes
        __tmp_changes_count=$(expr ${__tmp_changes_count} + 1)
        if [[ -z ${__tmp_changes_list} ]]; then
          __tmp_changes_list="${__source_file};${__target_file}"
        else
          __tmp_changes_list="${__tmp_changes_list}\n${__source_file};${__target_file}"
        fi
      fi
      # Increment total files compared
      __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
    done < <(find "${__source}" -not -path "*/.git/*" -type f -print0)
  else # Non-directory dotfile
    # Compare dotfiles in destination dir with local copy in home dir
    if cmp -s "${__source}" "${__target}"; then
      if [[ ${IS_SILENT} -ne 1 ]]; then
        echolog "No Changes detected in ${__source}"
      else
        log "No Changes detected in ${__source}"
      fi
    else
      if [[ ${IS_SILENT} -ne 1 ]]; then
        echolog "${YELLOW}Changes detected:${NC}"
        echolog "${BLUE}SOURCE ${__source}${NC}"
        echolog "${BLUE}TARGET ${__target}${NC}"
      else
        log "${YELLOW}Changes detected:${NC}"
        log "${BLUE}SOURCE ${__source}${NC}"
        log "${BLUE}TARGET ${__target}${NC}"
      fi
      # Record changes
      __tmp_changes_count=$(expr ${__tmp_changes_count} + 1)
      if [[ -z ${__tmp_changes_list} ]]; then
        __tmp_changes_list="${__source};${__target}"
      else
        __tmp_changes_list="${__tmp_changes_list}\n${__source};${__target}"
      fi
    fi
    # Increment total files compared
    __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
  fi

  # Return variables
  [[ -n "${__changes_list}" ]]       && eval $__changes_list="'$__tmp_changes_list'"
  [[ -n "${__changes_count}" ]]     && eval $__changes_count=$__tmp_changes_count
  [[ -n "${__total_files_count}" ]] && eval $__total_files_count=$__tmp_total_files_count
}

changes_list=""
total_changes=0
total_files_count=0

echolog "Detecting dotfiles changes..."
echolog
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip home directory from path
  home_stripped=$(echo "$dotfile" | sed "s,${HOME}/,,")
  # Strip trailing '/' in directory path
  home_stripped=$(echo "${home_stripped}" | sed -r "s,(.*)/$,\1,")

  cmp_files "${dotfile}" "${DOTFILES_DEST_DIR}/${home_stripped}" list changes_count files_count

  # Update changes list
  if [[ -n "${list}" ]]; then
    if [[ -z ${changes_list} ]]; then
      changes_list="${list}"
    else
      changes_list="${changes_list}\n${list}"
    fi
  fi
  # Increment counters
  [[ -z "${changes_count}" ]] && changes_count=0
  [[ -z "${files_count}" ]] && files_count=0
  total_changes=$(expr ${total_changes} + ${changes_count})
  total_files_count=$(expr ${total_files_count} + ${files_count})
done

# Abort if no dotfiles detected
[[ ${total_changes} -eq 0 ]] && abort "\nAborting... No dotfiles to backup."

echolog
echolog "${ULINE}Files with changes:${NC}"
echolog

# Loop over changes list and diff if IS_VERY_VERBOSE, else echolog source file
echo -e "${changes_list}" | while IFS= read -r file_tuple; do
  # Split file_tuple
  IFS=';' read -r -a file_arr <<< "${file_tuple}"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
  # Diff source and target file
  if [[ -n "${IS_VERY_VERBOSE}" ]]; then
    if command -v colordiff &> /dev/null; then
      diff -c "${source_file}" "${target_file}" | colordiff
    else
      diff -c "${source_file}" "${target_file}" --color
    fi
  else
    # echolog source file if not very verbose
    echolog "${YELLOW}${source_file}${NC}"
  fi
done

echolog
echolog "Total dotfiles: \t\t${total_files_count}"
echolog "${YELLOW}Total files with changes: \t${total_changes}${NC}"


# Confirmation
# see /bin/syntax-helpers/confirm
if [[ -z "${SKIP_CONFIRM}" ]]; then
  log "Do you wish to continue? (Y/y): "
  confirm "Do you wish to continue? (Y/y): "
  if [[ "${?}" -eq 1 ]]; then
    abort "Update aborted."
  elif [[ "${?}" -eq 2 ]]; then
    error "Unsupported shell"
  fi
fi

# Copy changes to destination directory
echo -e "${changes_list}" | while IFS= read -r file_tuple; do
  IFS=';' read -r -a file_arr <<< "$file_tuple"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
  # Copy source to target file
  cp -rL ${source_file} ${target_file} | log
done

# Final check
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip home directory from path
  home_stripped=$(echo "$dotfile" | sed "s,${HOME}/,,")
  # Strip trailing '/' in directory path
  home_stripped=$(echo "${home_stripped}" | sed -r "s,(.*)/$,\1,")

  cmp_files "${dotfile}" "${DOTFILES_DEST_DIR}/${home_stripped}" list changes_count files_count 1

  [[ ${changes_count} -gt 0 ]] && error "Dotupdate failed. Changes persists" 1
done

ok "${GREEN}Dotfiles update successful!${NC}"

