#!/bin/bash

################################################################################
# Updates all specified dotfiles in DOTFILES_LIST from DOTFILES_SOURCE_DIR into
# DOTFILES_TARGET_DIR.
# Uses `cmp` to compare files and `diff -c` to display changes when `-V` flag is
# given.
#
# The $DOTFILESRC specifies the location of .dotfilesrc file to override default
# script variables.
#
################################# DEPENDENCIES #################################
#
# ../../scripting-utils/colors  Pre-defined global variables for colorful string
#                               outputs.
# ../../scripting-utils/utils   Utility functions for detailed debugging
#                               outputs.
# ./detect                      Changes and deletion detection functions.
#
########################### Script Global Variables ############################
#
# DOTFILES_LIST       = Bash array list of config (dot) files or directory to
#                       update.
# DOTFILES_SOURCE_DIR = Default source directory to distribute dotfiles from.
# DOTFILES_TARGET_DIR = Default target directory to distribute dotfiles into.
# LOG_FILE_DIR        = Log file directory.
# LOG_FILE            = Log file name. Only logs on `-d` flag or debug mode.
#                       Defaults to current timestamp.
#
################################################################################
# Author : Mark Lucernas <https://github.com/marklcrns>
# Date   : 2020-08-05
################################################################################





################################################## CONSTANT GLOBAL VARIABLES ###

# Default script variables
DOTFILES_LIST=()
DOTFILES_SOURCE_DIR="${HOME}"
DOTFILES_TARGET_DIR="${HOME}/Projects/.dotfiles"
LOG_FILE_DIR="${HOME}/log"
LOG_FILE="$(date +"%Y-%m-%dT%H:%M:%S")_$(basename -- $0).log"

SCRIPTPATH="$(realpath -s $0)"
SCRIPTDIR=$(dirname ${SCRIPTPATH})

############################################## EXTERNAL DEPENDENCIES SCRIPTS ###

# Ansi color code variables
if [[ -e "${SCRIPTDIR}/../../scripting-utils/colors" ]]; then
  source "${SCRIPTDIR}/../../scripting-utils/colors"
else
  echo "${SCRIPTPATH} WARNING: Failed to source '../../scripting-utils/colors' dependency"
  echo
fi
# Utility functions
if [[ -e "${SCRIPTDIR}/../../scripting-utils/utils" ]]; then
  source "${SCRIPTDIR}/../../scripting-utils/utils"
else
  echo "${SCRIPTPATH} ERROR: Failed to source '../../scripting-utils/utils' dependency"
  exit 1
fi
# Detect utility for changes and deletion detection
if [[ -e "${SCRIPTDIR}/detect" ]]; then
  source "${SCRIPTDIR}/detect"
else
  echo "${SCRIPTPATH} ERROR: Failed to source './detect' dependency"
  exit 1
fi

# Source rc file if exist
[[ -e "${DOTFILESRC}" ]] && source "${DOTFILESRC}"

############################################################### FLAG OPTIONS ###

# Display help
usage() {
cat << EOF
USAGE:

Updates all specified dotfiles in DOTFILES_LIST from DOTFILES_SOURCE_DIR into
DOTFILES_TARGET_DIR.

  dotupdate [ -bdDsvVy ]

OPTIONS:

   -b : backup files
   -d : skip file deletion
   -D : debug mode (redirect output in log file)
   -s : silent
   -v : verbose
   -V : very verbose
   -y : skip confirmation
   -h : help

EOF
}

# Set flag options
while getopts "bdDsvVyh" opt; do
  case "$opt" in
    b) [[ -n "$IS_BACKUP"       ]] && unset IS_BACKUP                  || IS_BACKUP=true;;
    d) [[ -n "$NO_DELETE"       ]] && unset NO_DELETE                  || NO_DELETE=true;;
    D) [[ -n "$DEBUG"           ]] && unset DEBUG                      || DEBUG=true;;
    s) [[ -n "$IS_SILENT"       ]] && unset IS_SILENT                  || IS_SILENT=true;;
    v) [[ -n "$IS_VERBOSE"      ]] && unset IS_VERBOSE                 || IS_VERBOSE=true;;
    V) [[ -n "$IS_VERY_VERBOSE" ]] && unset IS_VERBOSE IS_VERY_VERBOSE || IS_VERBOSE=true; IS_VERY_VERBOSE=true;;
    y) [[ -n "$SKIP_CONFIRM"    ]] && unset SKIP_CONFIRM               || SKIP_CONFIRM=true;;
    h) usage && exit 0;;
    *) usage && echo -e "${SCRIPTPATH}:\n${RED}ERROR: Invalid flag.${NC}"
      exit 1
  esac
done 2>/dev/null
shift "$((OPTIND-1))" # explanation https://unix.stackexchange.com/a/214151

####################################################### PRE-EXECUTION SET UP ###

# Strip trailing '/' in DIR path variables
DOTFILES_SOURCE_DIR=$(echo ${DOTFILES_SOURCE_DIR} | sed 's,/*$,,')
DOTFILES_TARGET_DIR=$(echo ${DOTFILES_TARGET_DIR} | sed 's,/*$,,')
LOG_FILE_DIR=$(echo ${LOG_FILE_DIR} | sed 's,/*$,,')

# Log stdout and stderr to $LOG_FILE in $LOG_FILE_DIR
if [[ -n "${DEBUG}" ]]; then
  # Append LOG_FILE
  LOG_FILE_PATH="${LOG_FILE_DIR}/${LOG_FILE}"
  # Create log directory if not existing
  if [[ ! -d "${LOG_FILE_DIR}" ]]; then
    mkdir -p "${LOG_FILE_DIR}"
  fi
  # Initialize log file
  echo -e "${SCRIPTPATH} log outputs\n" > ${LOG_FILE_PATH}
fi

################################################## SCRIPT ARGUMENTS HANDLING ###

########################################################## SCRIPT EXECUTIONS ###

# # TODO: Make bidirectional
# #       Make diffing changes detect the most recent file
# # Compares two file path (would compare recursively if files are directories)
# # and returns all files with discrepancies.
# # Require at least 3 arguments or args $1, $2, and $3 to execute.
# #
# # ARGS:
# # $1 = Source file path
# # $2 = Target file path
# # $3 = List of detected changes, including source and target file path separated
# #      by ';', and delimited by '\n'.
# # $4 = Detected changes count
# # $5 = Total files compared
# # $6 = Pass in integer '1' to turn on IS_SILENT
# #
# # Returns $3, $4, $5 variable args with new values from execution.
# detect_changes() {
#   local __source=$1
#   local __target=$2
#   local __changes_list=$3
#   local __changes_count=$4
#   local __total_files_count=$5
#   local silent=$6
#
#   # Check args count
#   [[ $# -lt 3 ]] && echolog "${RED}${FUNCNAME[0]}: Invalid number of arguments${NC}" && return 1
#   # Exit if invalid path
#   [[ ! -e "${__source}" ]] && \
#     error "${SCRIPTPATH} ${FUNCNAME[0]}: Invalid source path \'${__source}\'" && return 2
#
#   local __tmp_changes_list
#   local __tmp_changes_count
#   local __tmp_total_files_count
#
#   # Strip all trailing backslashes '/'
#   __source=$(echo "${__source}" | sed 's,/*$,,')
#   __target=$(echo "${__target}" | sed 's,/*$,,')
#
#   if [[ -d "${__source}" ]]; then # Directory dotfile
#     # Recursively compare
#     while IFS= read -r -d '' __source_file; do
#       # Strip all trailing backslashes '/'
#       __source_file=$(echo "${__source_file}" | sed 's,/*$,,')
#       # Get relative path
#       __rel_path_file=$(echo "${__source_file}" | sed "s,${__source}/,,")
#       __target_file="${__target}/${__rel_path_file}"
#       # Compare dotfiles in target dir with local copy in source dir
#       if cmp -s "${__source_file}" "${__target_file}"; then
#         if [[ ${silent} -ne 1 ]]; then
#           echolog "No changes detected in ${__source_file}"
#         else
#           log "No changes detected in ${__source_file}"
#         fi
#       else
#         if [[ ! -e ${__target_file} ]]; then
#           echolog "${YELLOW}Missing file:${NC}" ${silent}
#           echolog "${BLUE}SOURCE ${__source_file}${NC}" ${silent}
#           echolog "${RED}TARGET ${__target_file}${NC}" ${silent}
#         else
#           echolog "${YELLOW}Changes detected:${NC}" ${silent}
#           echolog "${BLUE}SOURCE ${__source_file}${NC}" ${silent}
#           echolog "${BLUE}TARGET ${__target_file}${NC}" ${silent}
#         fi
#         # Record changes
#         __tmp_changes_count=$(expr ${__tmp_changes_count} + 1)
#         if [[ -z ${__tmp_changes_list} ]]; then
#           __tmp_changes_list="${__source_file};${__target_file}"
#         else
#           __tmp_changes_list="${__tmp_changes_list}\n${__source_file};${__target_file}"
#         fi
#       fi
#       # Increment total files compared
#       __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
#     done < <(find "${__source}" -not -path "*/.git/*" -type f -print0) # Process substitution for outside variables
#   else # Non-directory dotfile
#     # Compare dotfiles in target dir with local copy in source dir
#     if cmp -s "${__source}" "${__target}"; then
#       if [[ ${silent} -ne 1 ]]; then
#         echolog "No Changes detected in ${__source}"
#       else
#         log "No Changes detected in ${__source}"
#       fi
#     else
#       if [[ ! -e ${target_file} ]]; then
#         echolog "${YELLOW}Missing file:${NC}" ${silent}
#         echolog "${BLUE}SOURCE ${__source}${NC}" ${silent}
#         echolog "${RED}TARGET ${__target}${NC}" ${silent}
#       else
#         echolog "${YELLOW}Changes detected:${NC}" ${silent}
#         echolog "${BLUE}SOURCE ${__source}${NC}" ${silent}
#         echolog "${BLUE}TARGET ${__target}${NC}" ${silent}
#       fi
#       # Record changes
#       __tmp_changes_count=$(expr ${__tmp_changes_count} + 1)
#       if [[ -z ${__tmp_changes_list} ]]; then
#         __tmp_changes_list="${__source};${__target}"
#       else
#         __tmp_changes_list="${__tmp_changes_list}\n${__source};${__target}"
#       fi
#     fi
#     # Increment total files compared
#     __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
#   fi
#   # Return variables
#   [[ -n "${__changes_list}" ]]      && eval $__changes_list="'$__tmp_changes_list'"
#   [[ -n "${__changes_count}" ]]     && eval $__changes_count=$__tmp_changes_count
#   [[ -n "${__total_files_count}" ]] && eval $__total_files_count=$__tmp_total_files_count
# }
#
# # Compares two file path (would compare recursively if files are directories)
# # and returns all files that does not exists in the target file or directory.
# # Require at least 3 arguments or args $1, $2, and $3 to execute.
# #
# # ARGS:
# # $1 = Source file path
# # $2 = Target file path
# # $3 = List of source files that does not exist in the target file path.
# # $4 = Detected changes count
# # $5 = Total files compared
# # $6 = Pass in integer '1' to turn on silent
# #
# # Returns $3, $4, $5 variable args with new values from execution.
# detect_delete() {
#   local __source=$1
#   local __target=$2
#   local __changes_list=$3
#   local __deleted_count=$4
#   local __total_files_count=$5
#   local silent=$6
#
#   # Check args count
#   [[ $# -lt 3 ]] && echolog "${RED}${FUNCNAME[0]}: Invalid number of arguments${NC}" && return 1
#
#   local __tmp_changes_list
#   local __tmp_deleted_count
#   local __tmp_total_files_count
#
#   # Strip all trailing backslashes '/'
#   __source=$(echo "${__source}" | sed 's,/*$,,')
#   __target=$(echo "${__target}" | sed 's,/*$,,')
#
#   if [[ -d "${__source}" ]]; then # Directory dotfile
#     # Recursively compare
#     while IFS= read -r -d '' __source_file; do
#       # Strip all trailing backslashes '/'
#       __source_file=$(echo "${__source_file}" | sed 's,/*$,,')
#       # Get relative path
#       __rel_path_file=$(echo "${__source_file}" | sed "s,${__source}/,,")
#       __target_file="${__target}/${__rel_path_file}"
#       # Check deleted files
#       if [[ -e "${__target_file}" ]]; then
#         echolog "File exists ${__target_file}" ${silent}
#       else
#         echolog "${RED}File to be deleted ${__source_file}${NC}" ${silent}
#         # Record deletion if not NO_DELETE
#         if [[ -z "${NO_DELETE}" ]]; then
#           __tmp_deleted_count=$(expr ${__tmp_deleted_count} + 1)
#         fi
#         # Append to changes list
#         if [[ -z ${__tmp_changes_list} ]]; then
#           __tmp_changes_list="${__source_file}"
#         else
#           __tmp_changes_list="${__tmp_changes_list}\n${__source_file}"
#         fi
#       fi
#       # Increment total files compared
#       __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
#     done < <(find "${__source}" -not -path "*/.git/*" -type f -print0) # Process substitution for outside variables
#   else # Non-directory dotfile
#     # Check deleted files
#     if [[ -e "${__target}" ]]; then
#       echolog "File exist in ${__target}" ${silent}
#     else
#       echolog "${RED}File does not exist ${__source}${NC}" ${silent}
#       # Record changes
#       __tmp_deleted_count=$(expr ${__tmp_deleted_count} + 1)
#       if [[ -z ${__tmp_changes_list} ]]; then
#         __tmp_changes_list="${__source}"
#       else
#         __tmp_changes_list="${__tmp_changes_list}\n${__source}"
#       fi
#     fi
#     # Increment total files compared
#     __tmp_total_files_count=$(expr ${__tmp_total_files_count} + 1)
#   fi
#   # Return variables
#   [[ -n "${__changes_list}" ]]      && eval $__changes_list="'$__tmp_changes_list'"
#   [[ -n "${__deleted_count}" ]]     && eval $__deleted_count=$__tmp_deleted_count
#   [[ -n "${__total_files_count}" ]] && eval $__total_files_count=$__tmp_total_files_count
# }

total_changes_count=0
total_deleted_count=0
total_files_count=0

echolog "Detecting dotfiles changes..."
echolog
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip source directory from path
  source_stripped=$(echo "$dotfile" | sed "s,${DOTFILES_SOURCE_DIR}/,,")

  detect_changes "${dotfile}" "${DOTFILES_TARGET_DIR}/${source_stripped}" changes changes_count files_count
  detect_delete "${DOTFILES_TARGET_DIR}/${source_stripped}" "${dotfile}" delete delete_count

  # Initialize counters if none
  [[ -z "${changes_count}" ]] && changes_count=0
  [[ -z "${delete_count}" ]] && delete_count=0
  [[ -z "${files_count}" ]] && files_count=0

  # Update changes list
  if [[ -n "${changes}" ]]; then
    if [[ -z ${changes_list} ]]; then
      changes_list="${changes}"
    else
      changes_list="${changes_list}\n${changes}"
    fi
    # Increment changes counter
    total_changes_count=$(expr ${total_changes_count} + ${changes_count})
  fi
  if [[ -n "${delete}" ]]; then
    if [[ -z ${changes_list} ]]; then
      changes_list="${delete}"
    else
      changes_list="${changes_list}\n${delete}"
    fi
    # Increment delete counter
    total_deleted_count=$(expr ${total_deleted_count} + ${delete_count})
  fi
  # Increment total files counters
  total_files_count=$(expr ${total_files_count} + ${files_count} + ${delete_count})
done

# Abort if no changes or delete detected
[[ ${total_changes_count} -eq 0 ]] && [[ ${total_deleted_count} -eq 0 ]] &&
  abort "\nAborting... No dotfiles to update."

echolog
echolog "${ULINE}Files with changes:${NC}"
echolog

modified_files_count=0
new_files_count=0

# Loop over changes list and diff if IS_VERY_VERBOSE, else echolog source file
while IFS= read -r file_tuple; do
  # Split file_tuple
  IFS=';' read -r -a file_arr <<< "${file_tuple}"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
    # Copy source to target file
  if [[ -z "${target_file}" ]]; then # check if target_file is missing
    if [[ -z "${NO_DELETE}" ]]; then
      echolog "${RED}-${source_file}${NC}"
    else
      echolog "${RED}-${source_file} ${YELLOW}SKIPPED${NC}"
    fi
  elif [[ -e "${target_file}" ]]; then # check if target_file not existing
    # Diff source and target file
    if [[ -n "${IS_VERY_VERBOSE}" ]] && [[ -z "${silent}" ]]; then
      if command -v colordiff &> /dev/null; then
        diff -c "${target_file}" "${source_file}" | colordiff
        log "${source_file}" 1
      else
        diff -c "${target_file}" "${source_file}" --color
        log "${source_file}" 1
      fi
    else
      # echolog source file if not very verbose
      echolog "${YELLOW}${source_file}${NC}"
    fi
    modified_files_count=$((modified_files_count+1))
  else
    echolog "${GREEN}+${target_file}${NC}"
    new_files_count=$((new_files_count+1))
  fi
done < <(echo -e "${changes_list}") # Process substitution for outside variables

# Changes and deletes tally
echolog
echolog "Total files to update: \t\t${total_files_count}"
if [[ ${modified_files_count} -gt 0 ]]; then
  echolog "${YELLOW}Total changed files: \t\t${modified_files_count}${NC}"
fi
if [[ ${new_files_count} -gt 0 ]]; then
  echolog "${GREEN}Total new files: \t\t${new_files_count}${NC}"
fi
if [[ -z ${NO_DELETE} ]]; then
  if [[ ${total_deleted_count} -gt 0 ]]; then
    echolog "${RED}Total delete files: \t\t${total_deleted_count}${NC}"
  fi
else
  echolog "${RED}Total delete files: \t\t${YELLOW}SKIPPED${NC}"
fi
echolog

# Confirmation
if [[ -z "${SKIP_CONFIRM}" ]]; then
  log "Do you wish to continue? (Y/y): \n" 1
  confirm "Do you wish to continue? (Y/y): "
  if [[ "${?}" -eq 1 ]]; then
    abort "Update aborted."
  elif [[ "${?}" -eq 2 ]]; then
    error "Unsupported shell"
  fi
fi


# TODO: Implement more elegant dotfiles backup
# if [[ -n "${IS_BACKUP}" ]]; then
# fi

echolog
echolog "Updating dotfiles..."
echolog
# Copy changes to target directory and delete missing files
echo -e "${changes_list}" | while IFS= read -r file_tuple; do
  IFS=';' read -r -a file_arr <<< "$file_tuple"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
  target_dir="$(dirname "${target_file}")"
  if [[ -z "${target_file}" ]]; then # check if target_file is missing
    if [[ -z "${NO_DELETE}" ]]; then
      if execlog "rm -f ${source_file}" 1; then
        ok "${source_file} deleted"
      else
        error "Failed to delete ${source_file}"
      fi
    else
      warning "Skipping ${source_file} deletion"
    fi
  elif [[ -d "${target_dir}" ]]; then # Check target dir path
    if execlog "cp -rL ${source_file} ${target_file}" 1; then
      ok "${source_file} -> ${target_file}"
    else
      error "Failed to copy ${source_file} -> ${target_file}"
    fi
  else # Create target dir if not existing
    execlog "mkdir -p ${target_dir}"
    if execlog "cp -rL ${source_file} ${target_file}" 1; then
      ok "${source_file} -> ${target_file}"
    else
      error "Failed to copy ${source_file} -> ${target_file}"
    fi
  fi
done

#################################################################### WRAP UP ###

# Final check
log " " 1
log "Final check..." 1
log " " 1
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip source directory from path
  source_stripped=$(echo "$dotfile" | sed "s,${DOTFILES_SOURCE_DIR}/,,")

  detect_changes "${dotfile}" "${DOTFILES_TARGET_DIR}/${source_stripped}" changes changes_count files_count 1
  if [[ -z ${NO_DELETE} ]]; then
    detect_delete "${DOTFILES_TARGET_DIR}/${source_stripped}" "${dotfile}" delete delete_count files_count 1
  fi
done

# Catch final check errors
[[ ${changes_count} -gt 0 ]] || [[ ${delete_count} -gt 0 ]] &&
  error "Dotupdate failed. Changes persists" 2

finish "Dotfiles update successful!"

