#!/bin/bash

################################################################################
# Updates all specified dotfiles in DOTFILES_LIST from DOTFILES_SOURCE_DIR into
# DOTFILES_TARGET_DIR.
# Uses `cmp` to compare files and `diff -c` to display changes when `-V` flag is
# given.
#
# The $DOTFILESRC specifies the location of .dotfilesrc file to override default
# script variables.
#
################################# DEPENDENCIES #################################
#
# ../../scripting-utils/colors  Pre-defined global variables for colorful string
#                               outputs.
# ../../scripting-utils/utils   Utility functions for detailed debugging
#                               outputs.
# ./detect                      Changes and deletion detection functions.
#
########################### Script Global Variables ############################
#
# DOTFILES_LIST       = Bash array list of config (dot) files or directory to
#                       update.
# DOTFILES_SOURCE_DIR = Default source directory to distribute dotfiles from.
# DOTFILES_TARGET_DIR = Default target directory to distribute dotfiles into.
# LOG_FILE_DIR        = Log file directory.
# LOG_FILE            = Log file name. Only logs on `-d` flag or debug mode.
#                       Defaults to current timestamp.
#
################################################################################
# Author : Mark Lucernas <https://github.com/marklcrns>
# Date   : 2020-08-05
################################################################################





################################################## CONSTANT GLOBAL VARIABLES ###

# Default script variables
DOTFILES_LIST=()
DOTFILES_SOURCE_DIR="${HOME}"
DOTFILES_TARGET_DIR="${HOME}/Projects/.dotfiles"
LOG_FILE_DIR="${HOME}/log"
LOG_FILE="$(date +"%Y-%m-%dT%H:%M:%S")_$(basename -- $0).log"

SCRIPTPATH="$(realpath -s $0)"
SCRIPTDIR=$(dirname ${SCRIPTPATH})

############################################## EXTERNAL DEPENDENCIES SCRIPTS ###

# Ansi color code variables
if [[ -e "${SCRIPTDIR}/../../scripting-utils/colors" ]]; then
  source "${SCRIPTDIR}/../../scripting-utils/colors"
else
  echo "${SCRIPTPATH} WARNING: Failed to source '../../scripting-utils/colors' dependency"
  echo
fi
# Utility functions
if [[ -e "${SCRIPTDIR}/../../scripting-utils/utils" ]]; then
  source "${SCRIPTDIR}/../../scripting-utils/utils"
else
  echo "${SCRIPTPATH} ERROR: Failed to source '../../scripting-utils/utils' dependency"
  exit 1
fi
# Detect utility for changes and deletion detection
if [[ -e "${SCRIPTDIR}/detect" ]]; then
  source "${SCRIPTDIR}/detect"
else
  echo "${SCRIPTPATH} ERROR: Failed to source './detect' dependency"
  exit 1
fi

# Source rc file if exist
[[ -e "${DOTFILESRC}" ]] && source "${DOTFILESRC}"

############################################################### FLAG OPTIONS ###

# Display help
usage() {
cat << EOF
USAGE:

Updates all specified dotfiles in DOTFILES_LIST from DOTFILES_SOURCE_DIR into
DOTFILES_TARGET_DIR.

  dotupdate [ -bdDsvVy ]

OPTIONS:

   -b : backup files
   -d : skip file deletion
   -D : debug mode (redirect output in log file)
   -s : silent
   -v : verbose
   -V : very verbose
   -y : skip confirmation
   -h : help

EOF
}

# Set flag options
while getopts "bdDsvVyh" opt; do
  case "$opt" in
    b) [[ -n "$IS_BACKUP"       ]] && unset IS_BACKUP                  || IS_BACKUP=true;;
    d) [[ -n "$NO_DELETE"       ]] && unset NO_DELETE                  || NO_DELETE=true;;
    D) [[ -n "$DEBUG"           ]] && unset DEBUG                      || DEBUG=true;;
    s) [[ -n "$IS_SILENT"       ]] && unset IS_SILENT                  || IS_SILENT=true;;
    v) [[ -n "$IS_VERBOSE"      ]] && unset IS_VERBOSE                 || IS_VERBOSE=true;;
    V) [[ -n "$IS_VERY_VERBOSE" ]] && unset IS_VERBOSE IS_VERY_VERBOSE || IS_VERBOSE=true; IS_VERY_VERBOSE=true;;
    y) [[ -n "$SKIP_CONFIRM"    ]] && unset SKIP_CONFIRM               || SKIP_CONFIRM=true;;
    h) usage && exit 0;;
    *) usage && echo -e "${SCRIPTPATH}:\n${RED}ERROR: Invalid flag.${NC}"
      exit 1
  esac
done 2>/dev/null
shift "$((OPTIND-1))" # explanation https://unix.stackexchange.com/a/214151

####################################################### PRE-EXECUTION SET UP ###

# Strip trailing '/' in DIR path variables
DOTFILES_SOURCE_DIR=$(echo ${DOTFILES_SOURCE_DIR} | sed 's,/*$,,')
DOTFILES_TARGET_DIR=$(echo ${DOTFILES_TARGET_DIR} | sed 's,/*$,,')
LOG_FILE_DIR=$(echo ${LOG_FILE_DIR} | sed 's,/*$,,')

# Log stdout and stderr to $LOG_FILE in $LOG_FILE_DIR
if [[ -n "${DEBUG}" ]]; then
  # Append LOG_FILE
  LOG_FILE_PATH="${LOG_FILE_DIR}/${LOG_FILE}"
  # Create log directory if not existing
  if [[ ! -d "${LOG_FILE_DIR}" ]]; then
    mkdir -p "${LOG_FILE_DIR}"
  fi
  # Initialize log file
  echo -e "${SCRIPTPATH} log outputs\n" > ${LOG_FILE_PATH}
fi

################################################## SCRIPT ARGUMENTS HANDLING ###

########################################################## SCRIPT EXECUTIONS ###

total_changes_count=0
total_deleted_count=0
total_files_count=0

echolog "Detecting dotfiles changes..."
echolog
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip source directory from path
  source_stripped=$(echo "$dotfile" | sed "s,${DOTFILES_SOURCE_DIR}/,,")

  detect_changes "${dotfile}" "${DOTFILES_TARGET_DIR}/${source_stripped}" changes changes_count files_count
  detect_delete "${DOTFILES_TARGET_DIR}/${source_stripped}" "${dotfile}" delete delete_count

  # Initialize counters if none
  [[ -z "${changes_count}" ]] && changes_count=0
  [[ -z "${delete_count}" ]] && delete_count=0
  [[ -z "${files_count}" ]] && files_count=0

  # Update changes list
  if [[ -n "${changes}" ]]; then
    if [[ -z ${changes_list} ]]; then
      changes_list="${changes}"
    else
      changes_list="${changes_list}\n${changes}"
    fi
    # Increment changes counter
    total_changes_count=$(expr ${total_changes_count} + ${changes_count})
  fi
  if [[ -n "${delete}" ]]; then
    if [[ -z ${changes_list} ]]; then
      changes_list="${delete}"
    else
      changes_list="${changes_list}\n${delete}"
    fi
    # Increment delete counter
    total_deleted_count=$(expr ${total_deleted_count} + ${delete_count})
  fi
  # Increment total files counters
  total_files_count=$(expr ${total_files_count} + ${files_count} + ${delete_count})
done

# Abort if no changes or delete detected
[[ ${total_changes_count} -eq 0 ]] && [[ ${total_deleted_count} -eq 0 ]] &&
  abort "\nAborting... No dotfiles to update."

echolog
echolog "${ULINE}Files with changes:${NC}"
echolog

modified_files_count=0
new_files_count=0

# Loop over changes list and diff if IS_VERY_VERBOSE, else echolog source file
while IFS= read -r file_tuple; do
  # Split file_tuple
  IFS=';' read -r -a file_arr <<< "${file_tuple}"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
    # Copy source to target file
  if [[ -z "${target_file}" ]]; then # check if target_file is missing
    if [[ -z "${NO_DELETE}" ]]; then
      echolog "${RED}-${source_file}${NC}"
    else
      echolog "${RED}-${source_file} ${YELLOW}SKIPPED${NC}"
    fi
  elif [[ -e "${target_file}" ]]; then # check if target_file not existing
    # Diff source and target file
    if [[ -n "${IS_VERY_VERBOSE}" ]] && [[ -z "${silent}" ]]; then
      if command -v colordiff &> /dev/null; then
        diff -c "${target_file}" "${source_file}" | colordiff
        log "${source_file}" 1
      else
        diff -c "${target_file}" "${source_file}" --color
        log "${source_file}" 1
      fi
    else
      # echolog source file if not very verbose
      echolog "${YELLOW}${source_file}${NC}"
    fi
    modified_files_count=$((modified_files_count+1))
  else
    echolog "${GREEN}+${target_file}${NC}"
    new_files_count=$((new_files_count+1))
  fi
done < <(echo -e "${changes_list}") # Process substitution for outside variables

# Changes and deletes tally
echolog
echolog "Total files to update: \t\t${total_files_count}"
if [[ ${modified_files_count} -gt 0 ]]; then
  echolog "${YELLOW}Total changed files: \t\t${modified_files_count}${NC}"
fi
if [[ ${new_files_count} -gt 0 ]]; then
  echolog "${GREEN}Total new files: \t\t${new_files_count}${NC}"
fi
if [[ -z ${NO_DELETE} ]]; then
  if [[ ${total_deleted_count} -gt 0 ]]; then
    echolog "${RED}Total delete files: \t\t${total_deleted_count}${NC}"
  fi
else
  echolog "${RED}Total delete files: \t\t${YELLOW}SKIPPED${NC}"
fi
echolog

# Confirmation
if [[ -z "${SKIP_CONFIRM}" ]]; then
  log "Do you wish to continue? (Y/y): \n" 1
  confirm "Do you wish to continue? (Y/y): "
  if [[ "${?}" -eq 1 ]]; then
    abort "Update aborted."
  elif [[ "${?}" -eq 2 ]]; then
    error "Unsupported shell"
  fi
fi


# TODO: Implement more elegant dotfiles backup
# if [[ -n "${IS_BACKUP}" ]]; then
# fi

echolog
echolog "Updating dotfiles..."
echolog
# Copy changes to target directory and delete missing files
echo -e "${changes_list}" | while IFS= read -r file_tuple; do
  IFS=';' read -r -a file_arr <<< "$file_tuple"
  source_file="${file_arr[0]}"; target_file="${file_arr[1]}"
  target_dir="$(dirname "${target_file}")"
  if [[ -z "${target_file}" ]]; then # check if target_file is missing
    if [[ -z "${NO_DELETE}" ]]; then
      if execlog "rm -f ${source_file}" 1; then
        ok "${source_file} deleted"
      else
        error "Failed to delete ${source_file}"
      fi
    else
      warning "Skipping ${source_file} deletion"
    fi
  elif [[ -d "${target_dir}" ]]; then # Check target dir path
    if execlog "cp -rL ${source_file} ${target_file}" 1; then
      ok "${source_file} -> ${target_file}"
    else
      error "Failed to copy ${source_file} -> ${target_file}"
    fi
  else # Create target dir if not existing
    execlog "mkdir -p ${target_dir}"
    if execlog "cp -rL ${source_file} ${target_file}" 1; then
      ok "${source_file} -> ${target_file}"
    else
      error "Failed to copy ${source_file} -> ${target_file}"
    fi
  fi
done

#################################################################### WRAP UP ###

# Final check
log " " 1
log "Final check..." 1
log " " 1
for dotfile in ${DOTFILES_LIST[@]}; do
  # Strip source directory from path
  source_stripped=$(echo "$dotfile" | sed "s,${DOTFILES_SOURCE_DIR}/,,")

  detect_changes "${dotfile}" "${DOTFILES_TARGET_DIR}/${source_stripped}" changes changes_count files_count 1
  if [[ -z "${NO_DELETE}" ]]; then
    detect_delete "${DOTFILES_TARGET_DIR}/${source_stripped}" "${dotfile}" delete delete_count files_count 1
  fi
done

# Catch final check errors
[[ ${changes_count} -gt 0 ]] || [[ ${delete_count} -gt 0 ]] &&
  error "Dotupdate failed. Changes persists" 2

finish "Dotfiles update successful!"

