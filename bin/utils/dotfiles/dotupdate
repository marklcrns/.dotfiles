#!/bin/bash

# Updates all specified dotfiles from $DOTFILES_LIST into specified location.
#
# The $DOTFILESRC specifies the location of .dotfilesrc file to override default
# script variables.
#
# ############################## Script Variables ##############################
#
# DOTFILES_LIST = Bash array list of config (dot) files or directory to update.
# LOG_FILE_DIR  = Log file directory.
# LOG_FILE      = Log file name. Only logs on `-d` flag or debug mode.
#                       Defaults to current timestamp.
#
# ##############################################################################
#
# Author : Mark Lucernas -- https://github.com/marklcrns
# Date   : 2020-08-05


# Default script variables
DOTFILES_DEST_DIR="${HOME}/Projects/.dotfiles"
DOTFILES_LIST=()
LOG_FILE_DIR="${HOME}/log"
LOG_FILE="$(date +"%Y-%m-%dT%H:%M:%S")_$(basename -- $0).log"

# Source rc file if exist
if [[ -e "${DOTFILESRC}" ]]; then
  source "${DOTFILESRC}"
fi

# Display help
usage() {
cat << EOF
USAGE:

Updates all specified dotfiles from \$DOTFILES_LIST into specified location.

  dotupdate [ -dvy ]

OPTIONS:

   -d : debug mode (redirect output in log file)
   -v : verbose
   -y : skip confirmation
   -h : help

EOF
}


# Set flag options
while getopts "dvyh" opt; do
  case "$opt" in
    d) [[ -n "$DEBUG"        ]] && unset DEBUG        || DEBUG=true;;
    v) [[ -n "$IS_VERBOSE"   ]] && unset IS_VERBOSE   || IS_VERBOSE=true;;
    y) [[ -n "$SKIP_CONFIRM" ]] && unset SKIP_CONFIRM || SKIP_CONFIRM=true;;
    h) usage && exit 0;;
    *) error "Invalid flag.";;
  esac
done 2>/dev/null
shift "$((OPTIND-1))" # explanation https://unix.stackexchange.com/a/214151


SCRIPT_PATH="$(realpath -s "${0}")"
# Strip trailing '/' in DIR path variables
DOTFILES_DEST_DIR=$(echo ${DOTFILES_DEST_DIR} | sed -r "s,(.*)/$,\1,")
LOG_FILE_DIR=$(echo ${LOG_FILE_DIR} | sed -r "s,(.*)/$,\1,")

# Log stdout and stderr to $LOG_FILE in $LOG_FILE_DIR
if [[ -n "${DEBUG}" ]]; then
  # Strip trailing '/' in LOG_FILE_DIR path and append "/$LOG_FILE"
  LOG_FILE_PATH="$(echo ${LOG_FILE_DIR} | sed -r "s,(.*)/$,\1,")/${LOG_FILE}"
  # Create log directory if not existing
  if [[ ! -d "${LOG_FILE_DIR}" ]]; then
    mkdir -p "${LOG_FILE_DIR}"
  fi
  # Initialize log file
  echo -e "${SCRIPT_PATH} log outputs\n" > ${LOG_FILE_PATH}
fi


# STDOUT and STDERR colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() {
  # Stores message into $IN if string argument is passed in,
  # else read from stdin and store it in $IN (used with pipe '|').
  # Only log message on debug mode. Echoes $IN if used with pipe.
  if [[ -n "$1" ]]; then
    IN="$1"
    [[ -n "${DEBUG}" ]] && echo -e "${IN}" >> "${LOG_FILE_PATH}"
  else
    read IN
    if [[ -n ${IN} ]]; then
      [[ -n "${DEBUG}" ]] && echo -e "${IN}" | tee -a "${LOG_FILE_PATH}"
    fi
  fi

}

echolog(){
  message=$1
  if [[ -n "${message}" ]]; then
    # echo if verbose
    [[ -n ${IS_VERBOSE} ]] && echo -e "${message}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

ok() {
  message="$1"
  if [[ -n "${message}" ]]; then
    echo -e "${GREEN}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

warning() {
  message="$1"
  if [[ -n "${message}" ]]; then
    echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

abort() {
  message="$1"
  if [[ -n "${message}" ]]; then
    echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 0
}

error() {
  message="$1"
  exitcode="$2"
  if [[ -n "${message}" ]]; then
    echo -e "${RED}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  # Exit with specified exit code. Do not exit if no exit code
  if [[ -n ${exitcode} ]]; then
    [[ ${exitcode} -ge 0 ]] && exit ${exitcode}
  fi
}

# TODO: Fix
dotfiles_changes_count=0
echolog "Changes detected in..."
for dotfile in ${DOTFILES_LIST[@]};
do
  # Strip home directory from path
  home_stripped=$(echo $dotfile | sed "s,${HOME}/,,")
  # Strip trailing '/' in directory path
  home_stripped=$(echo ${home_stripped} | sed -r "s,(.*)/$,\1,")

  if [[ -d "${dotfile}" ]]; then
    for file in $(find "${dotfile}" -not -path "*/.git/*" -type f); do
      # Strip home directory from path
      home_stripped=$(echo "${file}" | sed "s,${HOME}/,,")
      # Suppress details of differences
      # diff -rq "${file}" "${DOTFILES_DEST_DIR}/${home_stripped}"/${file##*/}
      if [[ $(cmp "${file}" "${DOTFILES_DEST_DIR}/${home_stripped}") ]]; then
        echolog "${dotfile}"
      fi
      echo "${file}"
      echo "${DOTFILES_DEST_DIR}/${home_stripped}"
    done
  else
    if [[ $(cmp "${dotfile}" "${DOTFILES_DEST_DIR}/${home_stripped}") ]]; then
      echolog "${dotfile}"
    fi
  fi

  # Count changes
  let "dotfiles_changes_count++"
done

# Abort if no dotfiles detected
if [[ ${dotfiles_changes_count} -eq 0 ]]; then
  abort "\nAborting... No dotfiles to backup."
fi

echolog "\nTotal changes in DOTFILES_LIST path: ${dotfiles_changes_count}"

# Confirmation
# see /bin/syntax-helpers/confirm
if [[ -z "${SKIP_CONFIRM}" ]]; then
  log "Do you wish to continue? (Y/y)"
  confirm "Do you wish to continue? (Y/y) "
  if [[ "${?}" -eq 1 ]]; then
    abort "Update aborted."
  elif [[ "${?}" -eq 2 ]]; then
    error "Unsupported shell"
  fi
fi
