#!/bin/bash

# Limits to only 10 dotfiles backup at a time
# Appending to arrays: https://unix.stackexchange.com/a/395103
# Appending to integer and string: https://stackoverflow.com/a/18041780
# Looping through arrays: https://stackoverflow.com/a/8880633

DOTFILES_BACKUP_LIMIT=10
DOTFILES_BACKUP_DIR="${HOME}/.dotfiles.bak"
LOG_FILE_DIR="${HOME}/log"
LOG_FILE="$(date +"%Y-%m-%dT%H:%M:%S")_$(basename -- $0).log"

SCRIPTPATH="$( cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 ; pwd -P )"

# Ansi color code variables
RED="\e[0;91m"
BLUE="\e[0;94m"
GREEN="\e[0;92m"
YELLOW="\033[1;33m"
WHITE="\e[0;97m"
EXPAND_BG="\e[K"
RED_BG="\e[0;101m${expand_bg}"
BLUE_BG="\e[0;104m${expand_bg}"
GREEN_BG="\e[0;102m${expand_bg}"
YELLOW_BG="\e[0;103m${expand_bg}"
BOLD="\e[1m"
ULINE="\e[4m"
NC="\e[0m" # No/reset color


# Source rc file if exist
if [[ -e "${DOTFILESRC}" ]]; then
  source "${DOTFILESRC}"
fi


# Display help
usage() {
  cat << EOF
USAGE:

Backs up all specified dotfiles from \$DOTFILES_LIST into \$DOTFILES_BACKUP_DIR
within a current timestamp named directory.

  dotbackup [ -dsvy ]

OPTIONS:

   -d : debug mode (redirect output in log file)
   -s : silent
   -v : verbose
   -y : skip confirmation
   -h : help

EOF
}

# Set flag options
while getopts "dsvyh" opt; do
  case "$opt" in
    d) [[ -n "$DEBUG"        ]] && unset DEBUG        || DEBUG=true;;
    s) [[ -n "$IS_SILENT"    ]] && unset IS_SILENT    || IS_SILENT=true;;
    v) [[ -n "$IS_VERBOSE"   ]] && unset IS_VERBOSE   || IS_VERBOSE=true;;
    y) [[ -n "$SKIP_CONFIRM" ]] && unset SKIP_CONFIRM || SKIP_CONFIRM=true;;
    h) usage && exit 0;;
    *) usage && echo -e "${SCRIPTPATH}:\n${RED}ERROR: Invalid flag.${NC}"
      exit 1
  esac
done 2>/dev/null
shift "$((OPTIND-1))" # explanation https://unix.stackexchange.com/a/214151

# Overwrite default limit if given
[[ -n ${1} ]] && DOTFILES_BACKUP_LIMIT=$1

# Stores message into $IN if string argument is passed in, else read from stdin
# and store it in $IN (used with pipe '|').  Only log message on debug mode.
# Echoes $IN if used with pipe.
log() {
  if [[ -n "$1" ]]; then
    IN="$1"
    [[ -n "${DEBUG}" ]] && echo -e "${IN}" >> "${LOG_FILE_PATH}"
  else
    read IN
    if [[ -n ${IN} ]]; then
      [[ -n "${DEBUG}" ]] && echo -e "${IN}" | tee -a "${LOG_FILE_PATH}"
    fi
  fi
}

echolog(){
  message=$1
  if [[ -n "${message}" ]]; then
    # echo if verbose
    [[ -n "${IS_VERBOSE}" ]] && [[ -z "${IS_SILENT}" ]] && echo -e "${message}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  else # Print newline if no message
    [[ -n "${IS_VERBOSE}" ]] && echo -e ""
    [[ -n "${DEBUG}" ]] && echo -e "" >> "${LOG_FILE_PATH}"
  fi
}

ok() {
  message="$1"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${GREEN}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 0
}

warning() {
  message="$1"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

abort() {
  message="$1"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 1
}

error() {
  message="$1"
  exitcode="$2"
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && echo -e "${RED}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  # Exit with specified exit code. Do not exit if no exit code
  if [[ -n ${exitcode} ]]; then
    [[ ${exitcode} -ge 0 ]] && exit ${exitcode}
  fi
}

# Strip trailing '/' in DIR path variables
DOTFILES_BACKUP_DIR=$(echo "${DOTFILES_BACKUP_DIR}" | sed 's,/*$,,')
DOTFILES_DEST_DIR=$(echo ${DOTFILES_DEST_DIR} | sed -r "s,(.*)/$,\1,")
LOG_FILE_DIR=$(echo ${LOG_FILE_DIR} | sed -r "s,(.*)/$,\1,")

# Log stdout and stderr to $LOG_FILE in $LOG_FILE_DIR
if [[ -n "${DEBUG}" ]]; then
  # Strip trailing '/' in LOG_FILE_DIR path and append "/$LOG_FILE"
  LOG_FILE_PATH="$(echo ${LOG_FILE_DIR} | sed -r "s,(.*)/$,\1,")/${LOG_FILE}"
  # Create log directory if not existing
  if [[ ! -d "${LOG_FILE_DIR}" ]]; then
    mkdir -p "${LOG_FILE_DIR}"
  fi
  # Initialize log file
  echo -e "${SCRIPTPATH} log outputs\n" > ${LOG_FILE_PATH}
fi

################################# START SCRIPT #################################

to_remove_count=0
declare -a removed_array

echolog "Detecting backup files..."
echolog

# TODO: Loop
counter=0
backup_dir_count=$(ls ${DOTFILES_BACKUP_DIR} | wc -l)
# If limit == 0, Delete all. Else, delete dotbackups until equals limit
while [[ ${backup_dir_count} -gt ${counter} ]]; do
  to_remove=$(ls ${DOTFILES_BACKUP_DIR} | tail -1)
  # Delete dotfiles backup overflow
  echolog "${DOTFILES_BACKUP_DIR}/${to_remove}"
  # Append to array, increment remove count, and decrement counter
  removed_array+=("${to_remove[@]}\n")
  to_remove_count=$((to_remove_count+1))
  counter=$((counter-1))
done

# Confirmation
if [[ -z "${SKIP_CONFIRM}" ]]; then
  log "Do you wish to continue? (Y/y): "
  confirm "Do you wish to continue? (Y/y): "
  if [[ "${?}" -eq 1 ]]; then
    abort "Update aborted."
  elif [[ "${?}" -eq 2 ]]; then
    error "Unsupported shell"
  fi
fi

removed_count=0

if [[ ${to_remove_count} -eq 0 ]]; then
  # If still below limit
  echolog "Nothing to delete. Skipping..."
  echolog
else
  # Removed all dotfiles backup in removed_array
  for backup in ${removed_array[@]}; do
    rm -rfv "${backup}" | log
    echolog "${RED}${backup} deleted${NC}"
    removed_count=$((removed_count+1))
  done
  echolog "Total Removed: ${removed_count}"
fi

ok "Dotfiles backups cleared!"

