#!/bin/bash

# Clears dotfiles backups only upto DOTFILES_BACKUP_LIMIT. Clears all when
# DOTFILES_BACKUP_LIMIT is 0 or no arguments was given.
#
# The $DOTFILESRC specifies the location of .dotfilesrc file to override default
# script variables.
#
########################### Script Global Variables ############################
#
# DEFAULT_DOTFILES_BACKUP_LIMIT = Sets the default auto clean backup limit
# DOTFILES_BACKUP_DIR           = Specifies the location of backup files.
#                                 directory to backup.
# LOG_FILE_DIR                  = Log file directory.
# LOG_FILE                      = Log file name. Only logs on `-d` flag or debug
#                                 mode. Defaults to current timestamp.
#
################################################################################
#
# Author : Mark Lucernas <https://github.com/marklcrns>
# Date   : 2020-08-11


################################################## CONSTANT GLOBAL VARIABLES ###

LOG_FILE_DIR="${HOME}/log"
LOG_FILE="$(date +"%Y-%m-%dT%H:%M:%S")_$(basename -- $0).log"

SCRIPTPATH="$(realpath -s $0)"

# Ansi color code variables
RED="\e[0;91m"
BLUE="\e[0;94m"
GREEN="\e[0;92m"
YELLOW="\033[1;33m"
WHITE="\e[0;97m"
EXPAND_BG="\e[K"
RED_BG="\e[0;101m${expand_bg}"
BLUE_BG="\e[0;104m${expand_bg}"
GREEN_BG="\e[0;102m${expand_bg}"
YELLOW_BG="\e[0;103m${expand_bg}"
BOLD="\e[1m"
ULINE="\e[4m"
NC="\e[0m" # No/reset color


# Source rc file if exist
if [[ -e "${DOTFILESRC}" ]]; then
  source "${DOTFILESRC}"
fi

############################################################### FLAG OPTIONS ###

# Display help
usage() {
  cat << EOF
USAGE:

Clears dotfiles backups only up to DOTFILES_BACKUP_LIMIT. Clears all when
DOTFILES_BACKUP_LIMIT is 0 or no arguments was given.

  dotclearbak [ -dsvVy ] [ backup-limit ]

OPTIONS:

   -d : debug mode (redirect output in log file)
   -l : push string list of git repositories delimited by new line
   -s : silent
   -v : verbose
   -V : very verbose
   -y : skip confirmation
   -h : help

EOF
}

# Set flag options
while getopts "dl:svVyh" opt; do
  case "$opt" in
    d) [[ -n "$DEBUG"           ]] && unset DEBUG                      || DEBUG=true;;
    l) [[ -n "$IS_REPO_LIST"    ]] && unset IS_REPO_LIST               || IS_REPO_LIST=true; REPO_LIST=${OPTARG};;
    s) [[ -n "$IS_SILENT"       ]] && unset IS_SILENT                  || IS_SILENT=true;;
    v) [[ -n "$IS_VERBOSE"      ]] && unset IS_VERBOSE                 || IS_VERBOSE=true;;
    V) [[ -n "$IS_VERY_VERBOSE" ]] && unset IS_VERBOSE IS_VERY_VERBOSE || IS_VERBOSE=true; IS_VERY_VERBOSE=true;;
    y) [[ -n "$SKIP_CONFIRM"    ]] && unset SKIP_CONFIRM               || SKIP_CONFIRM=true;;
    h) usage && exit 0;;
    *) usage && echo -e "${SCRIPTPATH}:\n${RED}ERROR: Invalid flag.${NC}"
      exit 1
  esac
done 2>/dev/null
shift "$((OPTIND-1))" # explanation https://unix.stackexchange.com/a/214151


########################################################## UTILITY FUNCTIONS ###

# Log message into LOG_FILE_PATH. Can be used with pipeline '|' to log message
# from stdout.
# Second argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
# Echo message if IS_VERY_VERBOSE
log() {
  message=$1
  force_silent=$2
  if [[ -n "$message" ]]; then
    IN="$message"
    [[ -n "${DEBUG}" ]] && echo -e "${IN}" >> "${LOG_FILE_PATH}"
  else
    read IN
    if [[ -n ${IN} ]]; then
      [[ -n "${DEBUG}" ]] && echo -e "${IN}" >> "${LOG_FILE_PATH}"
    fi
    # Echo log message if IS_VERY_VERBOSE
    if [[ -n "${IS_VERY_VERBOSE}" ]]; then
      [[ ${force_silent} -ne 1 ]] && echo -e "$message" # Skip message if force_silent
    fi
  fi
}

# Echo message and log into LOG_FILE_PATH.
# Second argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
echolog(){
  message=$1
  force_silent=$2
  if [[ -n "${message}" ]]; then
    # echo if verbose
    [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e "${message}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  else # Print newline if no message
    [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e ""
    [[ -n "${DEBUG}" ]] && echo -e "" >> "${LOG_FILE_PATH}"
  fi
}

# Execute command string with `eval` then log into LOG_FILE_PATH
# Second argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
# Echo message if IS_VERBOSE
execlog() {
  command_string=$1
  force_silent=$2
  if [[ -n "${command_string}" ]]; then
    # echo if verbose
    [[ -n "${IS_VERBOSE}" ]] && [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e "${command_string}"
    # Log command_string on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${command_string}" >> "${LOG_FILE_PATH}"
    # execute command
    if eval "${command_string}"; then
      return 0
    else
      # echo if verbose
      [[ -n "${IS_VERBOSE}" ]] && [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
        echo -e "${RED}${FUNCNAME[0]}(): Command \'${command_string}\' failed${NC}"
      # Log command_string on debug mode
      [[ -n "${DEBUG}" ]] &&
        echo -e "${FUNCNAME[0]}(): Command \'${command_string}\' failed" >> "${LOG_FILE_PATH}"
      return 1
    fi
  else
    # Return error if no command given
    [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e "${RED}${FUNCNAME[0]}(): Command not found${NC}"
    [[ -n "${DEBUG}" ]] &&
      echo -e "${FUNCNAME[0]}: Command not found" >> "${LOG_FILE_PATH}"
    return 1
  fi
}

# Echo message in GREEN characters
# Second argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
ok() {
  message=$1
  force_silent=$2
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e "${GREEN}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

# Echo message in YELLOW characters
# Second argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
warning() {
  message=$1
  force_silent=$2
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
}

# Echo message in YELLOW characters and `exit` script with exit code 1
# Second argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
abort() {
  message=$1
  force_silent=$2
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e "${YELLOW}${message}${NC}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 1
}

# Echo message in RED characters and `exit` script with exit code 1.
# Second argument accepts integer to override default exit code.
# Third argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
error() {
  message=$1
  exit_code=$2
  force_silent=$3
  if [[ -n "${message}" ]]; then
    if [[ -n ${exit_code} ]]; then # Remove SCRIPTPATH if no exit code
      [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
        echo -e "${RED}\n${SCRIPTPATH}: ${message}${NC}"
    else
      [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
        echo -e "${RED}${message}${NC}"
    fi
    # Log message on debug mode
    if [[ -n ${exit_code} ]]; then # Remove SCRIPTPATH if no exit code
      [[ -n "${DEBUG}" ]] && echo -e "\n${SCRIPTPATH}: ${message}" >> "${LOG_FILE_PATH}"
    else
      [[ -n "${DEBUG}" ]] && echo -e "${message}" >> "${LOG_FILE_PATH}"
    fi
  fi
  # Exit with specified exit code. Do not exit if no exit code
  if [[ -n ${exit_code} ]]; then
    [[ ${exit_code} -ge 0 ]] && exit ${exit_code}
  fi
}

# Echo message in GREEN characters and `exit` with exit code 0
# Second argument accepts integer value of 1 only to force silent.
# Logs message on DEBUG.
finish() {
  message=$1
  force_silent=$2
  if [[ -n "${message}" ]]; then
    [[ -z "${IS_SILENT}" ]] && [[ ${force_silent} -ne 1 ]] &&
      echo -e "\n${message}"
    # Log message on debug mode
    [[ -n "${DEBUG}" ]] && echo -e "\n${message}" >> "${LOG_FILE_PATH}"
  fi
  exit 0
}

####################################################### PRE-EXECUTION SET UP ###

# Strip trailing '/' in DIR path variables
LOG_FILE_DIR=$(echo ${LOG_FILE_DIR} | sed 's,/*$,,')

# Log stdout and stderr to $LOG_FILE in $LOG_FILE_DIR
if [[ -n "${DEBUG}" ]]; then
  # Append LOG_FILE
  LOG_FILE_PATH="${LOG_FILE_DIR}/${LOG_FILE}"
  # Create log directory if not existing
  if [[ ! -d "${LOG_FILE_DIR}" ]]; then
    mkdir -p "${LOG_FILE_DIR}"
  fi
  # Initialize log file
  echo -e "${SCRIPTPATH} log outputs\n" > ${LOG_FILE_PATH}
fi

########################################################## SCRIPT EXECUTIONS ###

if [[ -z ${IS_REPO_LIST} ]]; then
  # Invalid argument check
  if [[ -n $1 ]]; then
    REPO=$1
    # Strip trailing '/' in directory path
    REPO=$(echo ${REPO} | sed 's,/*$,,')
  else
    usage && error "Valid argument required" 1
  fi
fi

pushrepo() {
  git_repo=$1
  interval=$2

  execlog "cd ${git_repo}"

  # Check if is git repo
  [[ ! -d ".git" ]] && error "${REPO} not a git repository" return 1
  # Set default interval to 1 if non given
  [[ -z ${interval} ]] && interval=1

  # Check for git repo changes
  changes=$(git status --porcelain)
  branch_name=$(git symbolic-ref --short -q HEAD)
  remote_head=$(git log --decorate --oneline | grep "origin/${branch_name}")
  # Add, commit and push if has changes
  if [[ -n ${changes} ]]; then
    warning "Changes detected in $(pwd). Pushing changes..."
    echolog "Adding all changes and committing in ${interval}..." && sleep ${interval}
    echolog
    execlog "git add ."
    execlog "git commit"
    execlog "git push --all"
    # If Authentication failed, push until successful or interrupted
    while [[ $? -eq 128 ]]; do
      execlog "git push --all"
    done
  elif [[ ! "${remote_head}" == *"HEAD ->"* ]]; then
    # if HEAD ahead of remote or has something to push. push repo.
    execlog "git push --all"
    while [[ $? -eq 128 ]]; do
      execlog "git push --all"
    done
  else
    echolog "No changes detected in $(pwd). Skipping..."
  fi
}

# Push REPO/REPO_LIST
if [[ -n "${IS_REPO_LIST}" ]]; then
  # Loop over all repo list excluding empty new line
  for line in $(echo ${REPO_LIST}); do
    # continue of line is empty String
    [[ -z $line ]] && continue
    # Wait until another git commit finish processing if exist
    if [[ -n $(ps -fc | grep "git commit$" | head -n 1 | awk '{print $2}') ]]; then
      execlog "wait $(ps -fc | grep "git commit$" | head -n 1 | awk '{print $2}')"
    fi
    # Go to a repo repo then push
    execlog "pushrepo ${line} 1"
  done
else
  execlog "pushrepo ${REPO} 1"
fi

#################################################################### WRAP UP ###

finish "All repo push complete!"

